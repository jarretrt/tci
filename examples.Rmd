---
title: "Selected examples using the TCI package"
author: "Ryan Jarrett"
date: "2/18/2020"
output: github_document
bibliography: "../Dropbox/Documents/Dissertation/paper1/Robust Closed-Loop Induction of General Anesthesia with Propofol/journal_submissions/AA/Extras/bibfile.bib"
---

```{r setup, include=FALSE}
library(knitr)
library(pander)
library(microbenchmark)
library(ggplot2)
library(reshape) 
library(gridExtra)
library(RColorBrewer)
setwd("~/tci")
source("./R/misc_functions.R") # miscellaneous functions unrelated to pkpd modeling
source("./R/pk_mods.R") # library of pk models
source("./R/pd_mods.R") # library of pd models
source("./R/pkpd_assist.R") # functions related to pkpd modeling
source("./R/tci_algorithms.R") # functions implementing TCI algorithms
source("./R/simulations.R") # functions implementing TCI simulations
source("./R/poppk_mods.R") # pre-saved population PK and PK-PD models
knitr::opts_chunk$set(echo = T, message = F, warning = F, fig.align="center")
```



## PK models

For illustration, we consider two PK models with IV infusions: a one-compartment model, and a three-compartment model with an effect-site compartment. 

The functions below gives the predicted concentrations in each compartment for both models associated with a continuous infusion of 1 mg/m over five minutes.

```{r, pk-1cpt}
tms <- seq(0,5,0.1)
pars_1cpt <- c(ke = 0.1, v = 10)
plot(tms, pkmod1cpt(tm = tms, kR = 1, pars = pars_1cpt, init = 0), type = "l", xlab = "min", ylab = "Cp")
```

```{r, pk-3cpt}
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
con <- pkmod3cptm(tm = tms, kR = 1, pars = pars_3cpt, init = c(0,0,0,0))
plot(tms, tms, type = "n", ylim = range(con), ylab = "concentration (mg/mL)", xlab = "min")
sapply(1:nrow(con), function(i) lines(tms, con[i,], col = i)); legend("topleft", paste("compartment",1:4), col = 1:4, lty = 1, cex = 0.8, bty = "n")
```



We now need to be able to extend each PK function to any arbitrary infusion schedule. We do this by  writing predict method for PK models that takes in a dosing schedule and returns predicted concentrations either for a grid of points across the duration of the dosing interval, or at specified time points. 
```{r, predict-pkmod}
# predict for 1cpt model
head(predict(pkmod = pkmod1cpt, inf = create_intvl(dose), pars = pars_1cpt, init = 2, return_init = T))
# predict for 3cpt model
head(predict(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt, return_init = T))
# predict for 3cpt model at specific values
head(predict(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt, tms = c(1,2,3)))
```



Finally, we create a plot method for PK models with set infusions. 

```{r, plot-pk-method}
plot(pkmod = pkmod1cpt, inf = create_intvl(dose), pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
plot(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt, title = "Concentrations for a 3 compartment model with an effect site")
```


## Target-controlled infusion (TCI) algorithms

All TCI algorithms are expected to take in a target concentration value, a PK model, and the duration of the infusion administered. Additional arguments specifying aspects such as the maximum infusion rate or the target compartment may be provided. When users want to supply a custom TCI algorithm, they will write an algorithm such as the one above that returns an infusion for a single target, as well as the amount of time required to do so. Later on we will provide a function that extends any TCI algorithm to multiple targets. TCI algorithms should return a vector of length 2 with named values "kR" and "dt" indicating the infusion rate and the duration of the infusion.

The algorithm below makes use of the approximate linearity in plasma concentrations associated with a continuous infusion and returns the infusion required to reach the target if administered for a duration of `dt`.

```{r, plasma-tci}
# find infusion to increase plasma concentration to 2 within 2 minutes.
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod1cpt, pars = pars_1cpt) 
# verify that infusion will reach target at 2 minutes
pkmod1cpt(tm = 2, pars = pars_1cpt, kR = inf_est[1])
plot(pkmod1cpt, pars = pars_1cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est[1],0))), 
     title = "Infusion required to reach a plasma concentration of 2")

# test for 3 compartment model with initial concentrations
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0)) 
pkmod3cptm(tm = 2, pars = pars_3cpt, kR = inf_est[1], init = c(1,0,0,0))
plot(pkmod3cptm, pars = pars_3cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est[1],0))), 
     init = c(1,0,0,0), title = "Infusion required to reach a plasma concentration of 2 in a 3cmpt model")
```


Now, we also create an effect-site TCI algorithm. This algorithm returns the infusion that, if administerd for a duration of `dt`, will reach the effect-site target in the minimum amount of time without overshoot.


```{r, effect-site-tci}
# calculate the 10 second infusion rate required to reach a concentration of 1 ug/ml in the effect-site compartment with existing drug in the first compartment. 
kR_Cet <- tci_effect(Cet = 1, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0), dt = 1/6)
inf <- create_intvl(data.frame(time = c(1/6, 20), infrt = c(kR_Cet["kR"],0)))
plot(pkmod3cptm, inf, pars = pars_3cpt, init = c(1,0,0,0), 
     title = "10-sec infusion to reach a Cet of 1 in a 3cmpt model with initial cons")

# The algorithm may also be used to specify target different compartments, if desired. 
# Find 1 minute infusion required to reach a concentration of 0.5 in compartment 2 with no prior infusions. 
infdt = 1
kR_Cet_cmpt2 <- tci_effect(Cet = 0.5, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(0,0,0,0), dt = infdt, cmpt = 2)
inf_cmpt2 <- create_intvl(data.frame(time = c(infdt, 20), infrt = c(kR_Cet_cmpt2["kR"],0)))
plot(pkmod3cptm, inf_cmpt2, pars = pars_3cpt, init = c(0,0,0,0),
     title = "1-min infusion to reach a c2 con of 0.5 in a 3cmpt model")
```



We now need a function to iterate any arbitrary TCI algorithm across a series of targets. By default, the function will update infusion rates at fixed intervals (e.g. every 10 seconds); however, users will have the option of waiting only calculating infusions after the prior target has been obtained. 

The user passes the `iterate_tci` function a matrix of target concentrations and times at which the target is set. This is translated into a step function that defines the concentration target at all times. 

<!-- 1. Set up target concentration function. -->
<!--   - The function should be left-continuous, such that each (time, Cet) combination defines the target at that time. The function will calculate infusions until the end of the time period defined. -->
<!-- 2. Define update schedule (to extent possible). Define vector of tci evaluation times (if possible), infusion durations -->
<!--   - May require function for finding and maintaining a constant infusion rate (numerically? Since it may not be possible for any arbitrary PK model) -->

```{r, iterate-tci}
tms <- c(0,5,10,15)
Cet <- c(2,1.5,1,1)
plot(stepfun(tms[-1], Cet), ylim = c(0,2), xlim = c(0,15), main = "Plasma-targeting TCI algorithm", xlab = "min", ylab = "concentration")

# one compartment model
tci_1cpt <- iterate_tci_grid(Cet, tms, pkmod = pkmod1cpt, pars = pars_1cpt, tci = "plasma")
lines(tci_1cpt$begin, tci_1cpt$c1_start, col = 2)

# three compartment model
tci_3cpt <- iterate_tci_grid(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt, tci = "plasma")
lines(tci_3cpt$begin, tci_3cpt$c1_start, col = 3)
legend("bottomright", c("One compartment", "Three compartments"), lty = c(1,1), col = c(2,3), cex = 0.8, bty = "n")

par(mfrow = c(1,2))
# effect-site targeting
tci_3cpt_effect <- iterate_tci_grid(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt)
plot(stepfun(tms[-1], Cet), ylim = c(0,7), xlim = c(0,15), main = "Plasma-targeting TCI algorithm", xlab = "min", ylab = "concentration")
lines(tci_3cpt_effect$begin, tci_3cpt_effect$c1_start, col = 2)
lines(tci_3cpt_effect$begin, tci_3cpt_effect$c4_start, col = 3)
legend("topright", c("Plasma", "Effect site"), lty = c(1,1), col = c(2,3), cex = 0.8, bty = "n")

# effect-site targeting with initial concentrations
tci_3cpt_effect_init <- iterate_tci_grid(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(2,0,0,2))
plot(stepfun(tms[-1], Cet), ylim = c(0,3), xlim = c(0,15), main = "Plasma-targeting TCI algorithm", xlab = "min", ylab = "concentration")
lines(tci_3cpt_effect_init$begin, tci_3cpt_effect_init$c1_start, col = 2)
lines(tci_3cpt_effect_init$begin, tci_3cpt_effect_init$c4_start, col = 3)
legend("topright", c("Plasma", "Effect site"), lty = c(1,1), col = c(2,3), cex = 0.8, bty = "n")
par(mfrow = c(1,1))
```




## Pharmacodynamic (PD) models

The user is also able to specify a PD model along with a PK model and pass on target PD values, which are translated into target concentrations through the inverse PD function, and then into infusion rates through a specified TCI algorithm.

We illustrate the incorporation of a PD model using the four-parameter Emax model. 

```{r, emax}
# Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
ce_seq <- seq(0,4,0.1)
plot(ce_seq, emax(ce_seq, pars_emax), type = "l", xlab = "Effect-site concentrtion (ug/mL)", ylab = "BIS", ylim = c(0,100))

# inverse Emax model
all.equal(inv_emax(emax(ce_seq, pars_emax), pars_emax), ce_seq)
```


We create a plotting method for PD models that allows the user to pass in a PK-PD model and an infusion schedule and plots the corresponding PK and PD profiles. 

```{r, plot-pd}
plot(pdmod = emax, 
     pkmod = pkmod3cptm, 
     pars_pd = pars_emax, 
     pars_pk = pars_3cpt, 
     inf = create_intvl(data.frame(time = c(2,4,6,10), 
                                   infrt = c(400,0,400,0))), 
     title = "Predicted PK-PD responses")
```


```{r, tci-pd}
tms <- seq(0,15,5)
bist <- c(40,50,70,70)
tci_bis_res <- tci_pd(pdresp = bist, 
                      tms = tms, 
                      pdinv = inv_emax, 
                      pdmod = emax,
                      pkmod = pkmod3cptm,
                      pars_pk = pars_3cpt,
                      pars_pd = pars_emax)

# plot TCI object with/without pd response
grid.arrange(plot(tci_3cpt_effect), plot(tci_bis_res), ncol = 2)
```



## Simulation functions

We need a function to generate data from a specified PK or PK-PD model given a set of infusions. The infusions are passed in the form of a matrix with columns specifying the infusion rate, the infusion duration, and the starting time of the infusion with the column headers ("infrt","begin","end"). All of these are provided as outputs from both the `create_intvl` and the `iterate_tci_grid` functions, so that the outputs can be passed directly to the `gen_data` function. Data can be generated at alternate times by specifying a set of times through the `tms` argument. 


```{r, gen-data}
# new set of PK parameters for 3 compartment model
pars_3cpt0 <- c(k10=1.7,k12=0.13,k21=0.1,k13=0.8,k31=0.8,v1=15,v2=16,v3=90,ke0=1.2)
# generate PK data sampled each minute with multiplicative error
pkdsim <- gen_data(inf = create_intvl(dose), pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0, 
         tms = seq(0,10,1), sigma.mult = 0.5)
head(pkdsim$sim)

# generate PK data for infusions starting at time t=10 using 
# final concentrations from prior simulation as initial values
dosetm10 <- dose
dosetm10$time  <- dosetm10$time+10
inittm10 <- unlist(tail(pkdsim$sim[,c("c1","c2","c3","c4")], 1))
pkdsimtm10 <- gen_data(inf = create_intvl(dosetm10, inittm = 10), 
                       pkmod = pkmod3cptm, 
                       pars_pk0 = pars_3cpt0, 
                       tms = seq(10,20,1), 
                       sigma.mult = 0.5, 
                       init = inittm10)
head(pkdsimtm10$sim)

# new set of PD parameters for Emax model
pars_emax0 <- c(c50 = 1.2, gamma = 3.5, E0 = 100, Emx = 100)

# Simulate PK-PD data under model misspecification.
# Predicted concentrations / responses under model with pars "pars_3cpt", "pars_emax"
tci_bis_res <- tci_pd(pdresp = c(40,50,70,70), 
                      tms = c(0,5,10,15), 
                      pdinv = inv_emax, 
                      pdmod = emax,
                      pkmod = pkmod3cptm,
                      pars_pk = pars_3cpt,
                      pars_pd = pars_emax)
# Generate data using infusion schedule above under a different PK-PD model
pkpddsim <- gen_data(inf = tci_bis_res, 
                     pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0, 
                     pdmod = emax, pars_pd0 = pars_emax0,
                     sigma.add = 7, delay = 15/60, max_pdval = 100)
head(pkpddsim$sim)

# Generate data at time t=15 with new targets and starting concentrations
tci_bis_res_init <- tci_pd(pdresp = c(40,50,70,70), 
                           tms = c(0,5,10,15)+15, 
                           pdinv = inv_emax, 
                           pdmod = emax,
                           pkmod = pkmod3cptm,
                           pars_pk = pars_3cpt,
                           pars_pd = pars_emax, 
                           init = unlist(tail(
                             pkpddsim$inf[,c("c1_end","c2_end","c3_end","c4_end")]
                             ,1))
                           )

# pass in true concentrations as starting concentrations
pkpddsim_init <- gen_data(inf = tci_bis_res_init, 
                          pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0, 
                          pdmod = emax, pars_pd0 = pars_emax0,
                          sigma.add = 7, delay = 15/60, max_pdval = 100,
                          init = unlist(tail(
                            pkpddsim$sim[,c("c1","c2","c3","c4")]
                            ,1)))
head(pkpddsim_init$sim)
```

We also would like a plot method for simulated data. 

```{r}
p1 <- plot(pkpddsim)
p2 <- plot(pkpddsim_init)
p12 <- plot(combine_sim(pkpddsim, pkpddsim_init))
grid.arrange(p1,p2,p12, layout_matrix = matrix(c(1,3,2,3),2,2))
```


We now define functions to generate hypothetical patient PK-PD data according to specified population PK or PK-PD models. While a number of commonly used models are provided in the file `poppk_mods.R`, such as the Marsh and Schnider PK models or the Eleveld PK-PD model, it is also possible for the user to define custom PK models. Each model should take in a dataframe of patient covariates and perform the relevant computation to calculate the patient's corresponding PK or PK-PD parameters. If random sampling from the population model is desired, it should be performed within the population PK or PK-PD function using the argument `rand`.

The `apply_poppk` function is a wrapper function for applying the stored population models. 


```{r, gen-patient-data}
# Simulate PK-PD for patients based on eleveld data
data(eleveld_pk)
eleveld_poppk(eleveld_pk[1:5,], rate = T) # pk data only with rate parameters
eleveld_poppk(eleveld_pk[1:5,], rate = F, PD = T, rand = T) # pk-pd data with clearance parameters and random error 
```



We now illustrate how the functions written can be applied to generate infusion schedules designed to match values of a target sigmoid function.

```{r, target-sigmoid}
tms_sigmoid <- seq(0,10,1/60) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute

# parameters of Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)

# apply tci algorithm to sigmoid targets
sig_tci_targets <- tci_pd(pdresp = targets_sigmoid, 
                          tms = tms_sigmoid, 
                          pdinv = inv_emax, 
                          pdmod = emax,
                          pkmod = pkmod3cptm,
                          pars_pk = pars_3cpt,
                          pars_pd = pars_emax)
plot(sig_tci_targets)
```







<!-- We now need a function to perform Bayesian updates to a PK-PD model parameters with simulated data. To do this, we first define functions for the log prior, log likelihood, and log posterior.  -->

<!-- ```{r, update-pkpd} -->
<!-- #' Parameter estimates from Eleveld et al. (2018) -->
<!-- eleveld_eta_pk_var <- c(0.610,0.565,0.597,0.265,0.346,0.209,0.463) -->
<!-- eleveld_eta_pd_var <- c(0.242,0.702,0.230) -->
<!-- lvars <- c(eleveld_eta_pk_var, eleveld_eta_pd_var) -->
<!-- names(lvars) <- c("V1","V2","V3","CL","Q2","Q3","RESID_PK","Ce50","ke0","RESID_PD") -->
<!-- lvars <- c(lvars, c(k10 = unname(lvars["CL"] + lvars["V1"]), -->
<!--                     k12 = unname(lvars["Q2"] + lvars["V1"]), -->
<!--                     k21 = unname(lvars["Q2"] + lvars["V2"]), -->
<!--                     k13 = unname(lvars["Q3"] + lvars["V1"]), -->
<!--                     k31 = unname(lvars["Q3"] + lvars["V3"]))) -->
<!-- lhyper0 <- diag(lvars[c("k10","k12","k21","k13","k31","V1","V2","V3","ke0","Ce50","RESID_PD")]) -->



<!-- #' Function to return the prior probability for a set of parameters assuming they are log-normally distributed. -->
<!-- #' It is assumed that the last value of of lpr is the prior mean for the variance parameter. -->
<!-- #' @param lpr log parameter values to evaluate -->
<!-- #' @param lhyper hyperparameters for mean and error distributions. List with values "mu", "sig" described below. -->
<!-- #' mu: mean for model parameters and mean of the error distribution -->
<!-- #' sig: variance covariance matrix for model parameters and standard deviation of error distribution -->
<!-- log_prior <- function(lpr, lhyper){ -->
<!--   dmvnorm(lpr, lhyper$mu, lhyper$sig, log = TRUE) -->
<!-- } -->

<!-- lpr <- log(c(pars_3cpt0, pars_emax0)) -->
<!-- lhyper -->
<!-- log_prior(lpr, ) -->

<!-- #' @param lpr log parameter values to evaluate -->
<!-- #' @param datasim object of class "datasim"  -->
<!-- log_likelihood <- function(lpr, datasim, ...){ -->

<!--   epr <- exp(lpr) -->
<!--   pklen <- length(datasim$pars_pk) -->
<!--   cp <- data.frame(predict(pkmod = datasim$pkmod,  -->
<!--                          inf = datasim$inf,  -->
<!--                          tms = datasim$sim$time, -->
<!--                          pars = head(epr,pklen), ...)) -->

<!--   pdp <- datasim$pdmod(ce = cp[,paste0("c",datasim$ecmpt)], pars = tail(epr,length(epr)-pklen)) -->

<!--   sum(truncnorm::dtruncnorm(x = datasim$sim$pdobs,  -->
<!--                             mean = pdp,  -->
<!--                             sd = datasim$sigma.add,  -->
<!--                             a = 0, b = 100)) -->
<!-- } -->


<!-- #' Function to evaluate the log likelihood given a set of logged parameter values and a set of observed BIS values. -->
<!-- #' @param lpr logged PK-PD-error parameter values -->
<!-- #' @param ivt infusion schedule -->
<!-- #' @param dat data frame with columns c("time","bis") corresponding to observed time and bis values -->
<!-- #' @param ini initial concentrations -->

<!-- log_likelihood <- function(lpr, ivt, dat, gamma, E0, ini = c(0,0,0,0), sum_vals = T){ -->
<!--   epr <- exp(lpr) -->
<!--   pars_pk <- epr[1:9]; pars_pd <- epr[10]; sig = epr[11] -->
<!--   sol <- pk_solution_3cpt_metab(pars_pk, ivt = ivt, init = ini) -->
<!--   con_est <- sol(dat$time) -->
<!--   con_est[con_est<0] <- 0 -->
<!--   bis_p <- Emax1(pars = pars_pd, ce = con_est[4,], gamma = gamma, E0 = E0) -->
<!--   # truncated normal distribution -->
<!--   if(sum_vals) {return(with(dat, sum(log(truncnorm::dtruncnorm(x = bis, mean = bis_p, sd = sig, a = 0, b = 100)))))} -->
<!--   else{return(with(dat, truncnorm::dtruncnorm(x = bis, mean = bis_p, sd = sig, a = 0, b = 100)))} -->
<!-- } -->


<!-- #' Function to evaluate the negative log posterior given a set of logged parameter values and observed BIS values. -->
<!-- #' @param lpr logged PK-PD-error parameter values -->
<!-- #' @param ivt infusion schedule -->
<!-- #' @param dat data frame with columns corresponding to  observed time and bis values -->
<!-- #' @param lhyper hyperparameter values to be passed to log_prior() -->
<!-- #' @param gamma gamma parameter of PD model (fixed in Eleveld model) -->
<!-- #' @param E0 E0 parameter of PD model (fixed in Eleveld model) -->
<!-- log_posterior_neg <- function(lpr, ivt, dat, lhyper, gamma, E0) { -->
<!--   dat <- na.omit(dat) -->
<!--   if(nrow(dat) < 1) { -->
<!--     -1*log_prior(lpr,lhyper) -->
<!--   } else { -->
<!--     -1*(log_prior(lpr,lhyper) + log_likelihood(lpr, ivt, dat, gamma = gamma, E0 = E0)) -->
<!--   } -->
<!-- } -->



<!-- update_mod <- function(mod, dat){ -->



<!-- } -->

<!-- update_pars <- function(lp, dat, ivt, lpr, gamma, E0){ -->
<!--   post_est <- nlm(f = log_posterior_neg, p = lp, ivt=ivt, dat=dat,  lhyper = lpr, gamma = gamma, E0 = E0, -->
<!--                   hessian = T, -->
<!--                   steptol=1e-6, gradtol=1e-6, stepmax = 5, -->
<!--                   iterlim = 2000) -->
<!--   post_est_pars <- post_est$estimate -->
<!--   post_hes <- post_est$hessian -->
<!--   lpost <- list(mu = post_est_pars, sig = solve(post_hes)) -->
<!--   return(lpost) -->
<!-- } -->


<!-- ``` -->













