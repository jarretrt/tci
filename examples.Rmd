---
title: "Selected examples using the TCI package"
author: "Ryan Jarrett"
date: "2/18/2020"
output: github_document
bibliography: "../Dropbox/Documents/Dissertation/paper1/Robust Closed-Loop Induction of General Anesthesia with Propofol/journal_submissions/AA/Extras/bibfile.bib"
---

```{r setup, include=FALSE}
library(knitr)
library(pander)
library(microbenchmark)
library(ggplot2)
library(reshape) 
library(gridExtra)
library(RColorBrewer)
library(devtools)
# library(tci)
setwd("~/tci")
devtools::load_all(".")
knitr::opts_chunk$set(echo = T, message = F, warning = F, fig.align="center")
```


In this vignette, we illustrate how to use the main functions of the `tci` R package. The primary purpose of the package is to allow the user to easily implement and simulate data from a variety of pharmacokinetic and pharmacodynamic (PK-PD) models under open- or closed-loop control using target-controlled infusion (TCI). TCI devices are used to provide partially-automated control over the delivery of medications. The device user typically selects from a list of PK models one believed to be appropriate for a given patient, as well as a target concentration. The TCI device then applies an algorithm to invert the PK model and return an infusion rate for a set duration that is predicted to achieve the target concentration in the patient. Though this vignette focuses on PK-PD models and TCI algorithms commonly used for control of propofol delivery, the functions can easily be adapted to alternate user-defined models and algorithms. 


## PK models

For illustration, we primarily demonstrate functions using a three-compartment mammillary model with an additional effect-site compartment. This model is selected because it is used for most population PK models for propofol, which is commonly administered via TCI. Nonetheless, the package contains a library with closed-form solutions for 1, 2, and 3, compartment models with intravenous (IV) infusions that could alternately be selected. We briefly illustrate the use of a one-compartment model below.

A central function in the package is a `predict` method for PK models. The user specifies a PK model from the library, model parameters, and a matrix providing a set of infusions with begin and end times. Predictions are returned either across a grid of points defined by the infusion schedule or at a set of time points that the user has specified.


```{r, predict-pkmod}
(dose <- create_intvl(as.matrix(cbind(time = c(0.5,4,4.5,10), infrt = c(100,0,100,0)))))

pars_1cpt <- c(ke = 0.1, v = 10)
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)

# predict for 1cpt model
head(predict(pkmod = pkmod1cpt, inf = dose, pars = pars_1cpt, init = 2, return_init = T))
# predict for 3cpt model
head(predict(pkmod = pkmod3cptm, inf = dose, pars = pars_3cpt, return_init = T))
# predict for 3cpt model at specific values
predict(pkmod = pkmod3cptm, inf = dose, pars = pars_3cpt, tms = c(1,2,3))
```

There is a corresponding `plot` method for objects with class `pkmod`. 

```{r, plot-pk-method}
plot(pkmod = pkmod1cpt, inf = dose, pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
plot(pkmod = pkmod3cptm, inf = dose, pars = pars_3cpt, title = "Concentrations for a 3 compartment model with an effect site")
```


## Target-controlled infusion (TCI) algorithms

Another core element of the `tci` package is its implementation of TCI algorithms. Broadly, TCI algorithms are used to invert a specified PK model such that a target concentration is supplied to the algorithm, which then calculates and returns the infusion rate required to reach the target. Most existing TCI algorithms either target the concentration in the central compartment (i.e. plasma) or the effect-site (e.g. brain) with the goal of reaching the target in as little time as possible, without overshooting the target. Algorithms to do this are provided by the package for both plasma and effect-site targeting. It is entirely possible, however, that an alternate algorithm could be desired. In this event, it is simple for the user to supply their own algorithm. 

All base TCI algorithms must take in a single target concentration as the first argument (e.g. `Cpt`), a PK model (`pkmod`), and the duration of the infusion administered (`dt`), and should return an infusion rate. Below we illustrate using the plasma-targeting algorithm specified by @Jacobs1990 for one- and three-compartment models.

```{r, plasma-tci}
# find infusion to increase plasma concentration to 2 within 2 minutes.
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod1cpt, pars = pars_1cpt) 
# verify that infusion will reach target at 2 minutes
plot(pkmod1cpt, pars = pars_1cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est,0))), 
     title = "Infusion required to reach a plasma concentration of 2")

# test for 3 compartment model with initial concentration in central compartment
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0)) 
plot(pkmod3cptm, pars = pars_3cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est,0))), 
     init = c(1,0,0,0), title = "Infusion required to reach a plasma concentration of 2 in a 3cmpt model")
```


We additionally implement a version of the effect-site algorithm described by @Shafer1992, in which the infusion is calculated such that the effect-site target concentration will be reached in as little time as possible without overshoot.


```{r, effect-site-tci}
# calculate the 10 second infusion rate required to reach a concentration of 1 ug/ml in the effect-site compartment with existing drug in the first compartment. 
kR_Cet <- tci_effect(Cet = 1, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0), dt = 1/6)
inf <- create_intvl(data.frame(time = c(1/6, 20), infrt = c(kR_Cet,0)))
plot(pkmod3cptm, inf, pars = pars_3cpt, init = c(1,0,0,0), 
     title = "10-sec infusion to reach a Cet of 1 in a 3cmpt model with initial cons")

# The algorithm may also be used to specify target different compartments, if desired. 
# Find 1 minute infusion required to reach a concentration of 0.5 in compartment 2 with no prior infusions. 
infdt = 1
kR_Cet_cmpt2 <- tci_effect(Cet = 0.5, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(0,0,0,0), dt = infdt, cmpt = 2)
inf_cmpt2 <- create_intvl(data.frame(time = c(infdt, 20), infrt = c(kR_Cet_cmpt2,0)))
plot(pkmod3cptm, inf_cmpt2, pars = pars_3cpt, init = c(0,0,0,0),
     title = "1-min infusion to reach a c2 con of 0.5 in a 3cmpt model")
```

At the base level, a TCI algorithm is defined to return a single infusion calculated to reach a single target. In practice, we often may wish to calculate a series of infusions required to reach a sequence of targets. This may be desired when gradually increasing or decreasing the target concentration, or alternately just to maintain a specific concentration for some duration of time. The `tci` function iterates any base TCI algorithm to do just this by taking in a series of targets and the times at which the targets are set and returning a series of infusions. The targets and times passed to `tci` are used to define a target step function. By default, the function will recalculate the infusion rate required to maintain the current target or adjust to a new target every 10 seconds.


```{r, iterate-tci}
tms <- c(0,5,10,15)
Cet <- c(2,1.5,1,1)

# one compartment model
tci_1cpt <- tci(Cet, tms, pkmod = pkmod1cpt, pars = pars_1cpt, tci_alg = "plasma")
plot(tci_1cpt, title = "Plasma-targeting for one-compartment model")

# three compartment model
tci_3cpt <- tci(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt, tci_alg = "plasma")
plot(tci_3cpt, title = "Plasma-targeting for three-compartment model")

# effect-site targeting
tci_3cpt_effect <- tci(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt)
plot(tci_3cpt_effect, title = "Effect-site targeting for three-compartment model")

# effect-site targeting with initial concentrations
tci_3cpt_effect_init <- tci(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(2,0,0,2))
plot(tci_3cpt_effect_init, title = "Effect-site targeting for three-compartment model and initial concentrations")
```


## Pharmacodynamic (PD) models

The user is also able to specify a PD model along with a PK model and pass on target PD values, which are translated into target concentrations through the inverse PD function, and then into infusion rates through a specified TCI algorithm.

We illustrate the incorporation of a PD model using the four-parameter Emax model. 

```{r, emax}
# Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, e0 = 100, emx = 100)
ce_seq <- seq(0,4,0.1)
# inverse Emax model
all.equal(inv_emax(emax(ce_seq, pars_emax), pars_emax), ce_seq)
```

A plotting method also exists for PD models. By default, the PK profile will be plotted alongside the PD response; however, this can be suppressed by setting the `plot_pk` argument to false.

```{r, plot-pd}
plot(pdmod = emax, 
     pkmod = pkmod3cptm, 
     pars_pd = pars_emax, 
     pars_pk = pars_3cpt, 
     inf = create_intvl(data.frame(time = c(2,4,6,10), 
                                   infrt = c(400,0,400,0))), 
     title = "Predicted PK-PD responses")
```


Target responses, rather than concentrations, can also be set and evaluated by a TCI algorithm through the `tci_pd` function, which extends the function `tci` to PD targets. The user must specify the same PK information required by `tci` in addition to a PD model and its inverse. 

```{r, tci-pd}
tms <- seq(0,15,5)
bist <- c(40,50,70,70)
tci_bis_res <- tci_pd(pdresp = bist, 
                      tms = tms, 
                      pdinv = inv_emax, 
                      pdmod = emax,
                      pkmod = pkmod3cptm,
                      pars_pk = pars_3cpt,
                      pars_pd = pars_emax)

# plot TCI object with pd response
plot(tci_bis_res, title = "Extension of TCI algorithm to PD targets")
```



## Simulation functions

We first introduce a function to generate data from a specified PK or PK-PD model given a set of infusions. The infusions are passed either as an object from the `create_intvl` or the `tci` or `tci_pd` functions. Observation times are set through the `tms` argument. Errors are assumed to be normally or log-normally distributed and can be specified to be additive or multiplicative.


```{r, gen-data}
# Simulate PK-PD data under model misspecification.
# true parameters: pars_3cpt0, pars_emax0
# prior parameters: pars_3cpt, pars_emax
pars_3cpt0 <- c(k10=1.7,k12=0.13,k21=0.1,k13=0.8,k31=0.8,v1=15,v2=16,v3=90,ke0=1.2)
pars_emax0 <- c(c50 = 1.2, gamma = 3.5, e0 = 100, emx = 100)

# Predicted concentrations / responses under model with pars "pars_3cpt", "pars_emax"
tci_bis_res <- tci_pd(pdresp = c(40,50,70,70), 
                      tms = c(0,5,10,15), 
                      pdinv = inv_emax, 
                      pdmod = emax,
                      pkmod = pkmod3cptm,
                      pars_pk = pars_3cpt,
                      pars_pd = pars_emax)
# Generate data using infusion schedule above under a different PK-PD model
pkpddsim <- gen_data(inf = tci_bis_res, 
                     pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0, 
                     pdmod = emax, pars_pd0 = pars_emax0,
                     sigma_add = 7)
head(pkpddsim$sim)
(p1 <- plot(pkpddsim))
```

Data can similarly be generated with later starting times and be merged with prior data through the `combine_sim` function.

```{r}
# Generate data at time t=15 with new targets and starting concentrations from previous tci
tci_bis_res_init <- tci_pd(pdresp = c(40,50,70,70), 
                           tms = c(0,5,10,15)+15, 
                           pdinv = inv_emax, 
                           pdmod = emax,
                           pkmod = pkmod3cptm,
                           pars_pk = pars_3cpt,
                           pars_pd = pars_emax, 
                           init = tci_bis_res[nrow(tci_bis_res), grep("c[0-9]_end",colnames(tci_bis_res))])

# pass in true concentrations as starting concentrations
pkpddsim_init <- gen_data(inf = tci_bis_res_init, 
                          pkmod = pkmod3cptm, 
                          pdmod = emax, 
                          pars_pk0 = pars_3cpt0, 
                          pars_pd0 = pars_emax0,
                          sigma_add = 7, 
                          init = pkpddsim$sim[nrow(pkpddsim$sim),c("c1","c2","c3","c4")])

(p12 <- plot(combine_sim(pkpddsim, pkpddsim_init)))
```


In many cases, users may wish to apply pre-existing population PK-PD models to a data frame of patient covariates. A preliminary step in doing this is calculating patient PK-PD parameters from the patient covariates, given a specific model. Functions are provided in the file `poppk_mods.R` to do this calculation for a number of commonly used models, such as the Marsh and Schnider PK models or the Eleveld PK-PD model.  Each model should take in a data frame of patient covariates and perform the relevant computation to calculate the patient's corresponding PK or PK-PD parameters. If random sampling from the population model is desired, it should be performed within the population PK or PK-PD function using the argument `rand`. 


```{r, gen-patient-data}
# Simulate PK-PD for first 5 patients based on eleveld data
data(eleveld_pk)
# pk data only with rate parameters
eleveld_poppk(eleveld_pk[1:5,], rate = T) 
# pk-pd data with clearance parameters and random error 
eleveld_poppk(eleveld_pk[1:5,], rate = F, PD = T, rand = T) 
```


### Open-loop control

Given a set of patient PK-PD parameters, we may reasonably want to know how patients would respond given a set of infusions (i.e. under open-loop control). To illustrate open-loop control, we consider applying open-loop control to the population of 122 patients described in the Eleveld et al. (2018) dataset. Infusion schedules are generated under two different conditions: 1) a target of BIS = 50, 2) a single target sigmoid function, evaluated at the prior PK-PD parameter values for each individual. The Eleveld PK-PD model is used in both scenarios and the target sigmoid curve is restricted to pass through BIS = 50 at 10 minutes and reach the level of 50% effect at one minute.


<!-- ```{r, target-sigmoid} -->
<!-- tms_sigmoid <- seq(0,10,1/60) # 10 minute induction with target sigmoid -->
<!-- targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute -->

<!-- # parameters of Emax model -->
<!-- pars_emax <- c(c50 = 1.5, gamma = 4, e0 = 100, emx = 100) -->

<!-- # apply tci algorithm to sigmoid targets -->
<!-- sig_tci_targets <- tci_pd(pdresp = targets_sigmoid,  -->
<!--                           tms = tms_sigmoid,  -->
<!--                           pdinv = inv_emax,  -->
<!--                           pdmod = emax, -->
<!--                           pkmod = pkmod3cptm, -->
<!--                           pars_pk = pars_3cpt, -->
<!--                           pars_pd = pars_emax) -->

<!-- # expected concentration- and BIS-time curves -->
<!-- plot(sig_tci_targets) -->
<!-- ``` -->


<!-- Using this approach, we can simulate open-loop control for a set of patients under different infusion schedules.  -->

<!-- This infusion schedule can be applied to a population of patients so simulate an open-loop TCI scenario. For this we use a sample of 10 patients from the population of 122 patients with PK-PD observations included in the Eleveld et al. (2018) dataset. For each  -->

<!-- We first simulate the expected time-BIS course for each patient when the correct patient models are passed on to the TCI algorithm. We later illustrate the same situation in which patient parameters are simulated with random error to reflect a more accurate clinical scenario.  -->

<!-- It is worth noting that the hill parameter ("gamma") in the Eleveld PD model is fixed across the population, but varies between two values depending on if the effect-site concentration is greater than the concentration required for 50% effect. To implement this, a modification of the Emax function and its inverse is required.  -->

```{r, open-loop-eleveld}
## Simulation without error
# Note: the parameter estimates in the Eleveld dataset are the EB estimates rather than the prior estimates

## Generate population PK-PD
# predicted model parameters for each patient - simulate without random error
ix <- ceiling(seq(1,122,length.out = 10))
eleveld_pop_prior <- eleveld_poppk(eleveld_pk[ix,], rate = T, PD = T, rand = F)
# simulate true patient parameters
set.seed(1)
eleveld_pop <- eleveld_poppk(eleveld_pk[ix,], rate = T, PD = T, rand = T)


## Infusions with fixed BIS = 50 target
fixed_tci_pop <- lapply(1:nrow(eleveld_pop), function(i){
        
        # base tci infusions on prior parameter estimates
        pars_pki <- unlist(eleveld_pop_prior[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
        pars_pdi <- unlist(eleveld_pop_prior[i,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
        names(pars_pdi) <- c("c50","gamma","gamma2","e0","emx")
        out <- tci_pd(pdresp = c(50,50), 
                        tms = c(0,10), 
                        pdinv = inv_emax_eleveld, 
                        pdmod = emax_eleveld,
                        pkmod = pkmod3cptm,
                        pars_pk = pars_pki,
                        pars_pd = pars_pdi)
        out <- cbind(id = i, out)
        out
})


## Sigmoid targets - single set of targets, evaluated at each 
## set of prior parameters.
tms_sigmoid <- seq(0,10,1/60) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1, BIS0 = eleveld_pop$BIS0[1]))

# apply tci algorithm to sigmoid targets
sig_tci_pop <- lapply(1:nrow(eleveld_pop), function(i){
        
        # base tci infusions on prior parameter estimates
        pars_pki <- unlist(eleveld_pop_prior[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
        pars_pdi <- unlist(eleveld_pop_prior[i,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
        names(pars_pdi) <- c("c50","gamma","gamma2","e0","emx")
        out <- tci_pd(pdresp = targets_sigmoid, 
                        tms = tms_sigmoid, 
                        pdinv = inv_emax_eleveld, 
                        pdmod = emax_eleveld,
                        pkmod = pkmod3cptm,
                        pars_pk = pars_pki,
                        pars_pd = pars_pdi)
        out <- cbind(id = i, out)
        out
})

## plot expected results

fixed_pop_df <- as.data.frame(
  do.call("rbind", 
          lapply(fixed_tci_pop, function(x)x[,c("id","begin","pdt","pdresp_start")])
          )
  )

sig_pop_df <- as.data.frame(
  do.call("rbind", 
          lapply(sig_tci_pop, function(x)x[,c("id","begin","pdt","pdresp_start")])
          )
  )

p1 <- ggplot(fixed_pop_df, aes(x = begin, y = pdresp_start, group = id)) + 
        geom_line(aes(x = begin, y = pdt), color = pal[1], size = 1.2) + 
        geom_line(alpha = 0.6, color = pal[2]) +
        lims(y = c(0,100))

p2 <- ggplot(sig_pop_df, aes(x = begin, y = pdresp_start, group = id)) + 
        geom_line(aes(x = begin, y = pdt), color = pal[1], size = 1.2) + 
        geom_line(alpha = 0.6, color = pal[2]) +
        lims(y = c(0,100))

# expected time-BIS profiles
grid.arrange(p1, p2)
```


```{r, sim-pop-error}
# apply tci algorithm to sigmoid targets
fixed_tci_datasim <- sig_tci_datasim <- vector("list", nrow(eleveld_pop))

for(i in 1:nrow(eleveld_pop)){
  # generate data based on "true" parameter values
  pars_pki0 <- unlist(eleveld_pop[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
  pars_pdi0 <- unlist(eleveld_pop[i,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
  names(pars_pdi0) <- c("c50","gamma","gamma2","e0","emx")
  
  # fixed bis target
  fixed_tci_datasim[[i]] <- gen_data(inf = fixed_tci_pop[[i]], 
                        pkmod = pkmod3cptm, 
                        pdmod = emax_eleveld, 
                        pars_pk0 = pars_pki0, # true pk parameters
                        pars_pd0 = pars_pdi0, # true pd parameters
                        sigma_add = eleveld_pop[i,"SIGMA"], # random error
                        delay = eleveld_pop[i,"BIS_DELAY"], # bis delay
                        max_pdval = 100,
                        init = c(0,0,0,0))
  fixed_tci_datasim[[i]]$sim <- cbind(id = i, fixed_tci_datasim[[i]]$sim)
  
  # sigmoid target
  sig_tci_datasim[[i]] <- gen_data(inf = sig_tci_pop[[i]], 
                        pkmod = pkmod3cptm, 
                        pdmod = emax_eleveld, 
                        pars_pk0 = pars_pki0, # true pk parameters
                        pars_pd0 = pars_pdi0, # true pd parameters
                        sigma_add = eleveld_pop[i,"SIGMA"], # random error
                        delay = eleveld_pop[i,"BIS_DELAY"], # bis delay
                        max_pdval = 100,
                        init = c(0,0,0,0))
  sig_tci_datasim[[i]]$sim <- cbind(id = i, sig_tci_datasim[[i]]$sim)
        
}


fixed_tci_datasim_df <- subset(
        as.data.frame(do.call("rbind", lapply(fixed_tci_datasim, `[[`, "sim"))), 
        select = c(id,time,pd0,pdobs)
        )

sig_tci_datasim_df <- subset(
        as.data.frame(do.call("rbind", lapply(sig_tci_datasim, `[[`, "sim"))), 
        select = c(id,time,pd0,pdobs)
        )
        
p3 <- ggplot(fixed_pop_df, aes(x = begin, y = pdresp_start, group = id)) + 
        geom_line(aes(x = begin, y = pdt, group = id, color = "Target"), 
                  size = 1.2) + 
        geom_line(alpha = 0.6, aes(color = "Predicted")) +
        geom_line(data = fixed_tci_datasim_df, 
                  aes(x = time, y = pd0, group = id, color = "Observed"), 
                  alpha = 0.6) +
        lims(y = c(0,100)) +
        scale_color_manual(name = "", 
                     values = c("Target"    = unname(pal[1]), 
                                "Predicted" = unname(pal[2]),
                                "Observed"  = unname(pal[5])))

p4 <- ggplot(sig_pop_df, aes(x = begin, y = pdresp_start, group = id)) + 
        geom_line(aes(x = begin, y = pdt, group = id, color = "Target"), 
                  size = 1.2) + 
        geom_line(alpha = 0.6, aes(color = "Predicted")) +
        geom_line(data = sig_tci_datasim_df, 
                  aes(x = time, y = pd0, group = id, color = "Observed"), 
                  alpha = 0.6) +
        lims(y = c(0,100)) +
        scale_color_manual(name = "", 
                     values = c("Target"    = unname(pal[1]), 
                                "Predicted" = unname(pal[2]),
                                "Observed"  = unname(pal[5])))

grid.arrange(p3, p4)
```


### Closed-loop control

In addition to open-loop control, closed-loop control can be implemented through Bayesian updates to a patient-specific PK or PK-PD model. We begin by illustrating the process of updating the prior patient model with a single set of data. In general, however, closed-loop control is implemented through the function `bayes_control` which allows for multiple sequential updates. 


Using a target-sigmoid infusion schedule, we consider first updating the PK-PD model parameters after data have been collected for the first five minutes, with BIS measurements made once every 10 seconds.

```{r, pd-update-example}
# update after 5 minutes of following sigmoid targets with observations collected every second
starttm = 0; endtm = 5; dt_obs = 1/6; dt_tci = 1/60
tms_sigmoid <- seq(starttm,endtm,dt_tci) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1, BIS0 = 93)) # parameters restricted to reach mid point at t=1 minute

# prior pk-pd parameters for 1st patient in Eleveld dataset
pars_pk_prior <- unlist(eleveld_pop_prior[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_prior <- unlist(eleveld_pop_prior[1,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_prior) <- c("c50","gamma","gamma2","e0","emx")

# prior distribution hyperparameters
# the 'elvdlpars' function extracts the pk-pd parameters from the Eleveld dataset
lpr_eval <- elvdlpars(eleveld_pop_prior[1,])
mu0 <- elvdlpars(eleveld_pop[1,])
sig0 <- poppk_cov("Eleveld")

# Calculate tci infusions at prior parameter estimates
inf <- tci_pd(pdresp  = targets_sigmoid, 
              tms     = tms_sigmoid, 
              pdinv   = inv_emax_eleveld, 
              pdmod   = emax_eleveld,
              pkmod   = pkmod3cptm,
              pars_pk = pars_pk_prior,
              pars_pd = pars_pd_prior)

# expected time course under correct model specification
plot(inf)

# true pk-pd parameters for patient
pars_pk_true <- unlist(eleveld_pop[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_true <- unlist(eleveld_pop[1,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])

# simulate data based on true pk-pd parameters
# generate observations every second
tms_obs <- seq(dt_obs,endtm,dt_obs)
dat <- gen_data(inf = inf, 
                tms = tms_obs,
                pkmod = pkmod3cptm, 
                pdmod = emax_eleveld, 
                pars_pk0 = pars_pk_true, # true pk parameters
                pars_pd0 = pars_pd_true, # true pd parameters
                sigma_add = eleveld_pop[1,"SIGMA"], # random error
                delay = eleveld_pop[1,"BIS_DELAY"]/60, # bis delay in minutes
                max_pdval = 100,
                init = c(0,0,0,0))

# fixed parameters that need to be used, but aren't evaluated in likelihood
# ordering of parameters is important to correct use of PD function
fixed_lpr <- log(as.numeric(eleveld_pop_prior[1,c("GAMMA","GAMMA2","BIS0","BIS0")]))

# update parameter estimates with data
post_est <- nlm(f = log_posterior_neg, 
                p = unname(elvdlpars(eleveld_pop_prior[1,])),
                dat = dat, 
                mu = unname(elvdlpars(eleveld_pop[1,])),
                sig = poppk_cov("Eleveld"),
                fixed_lpr = fixed_lpr, 
                hessian = T)

plot(dat, lpars_update = post_est$estimate, lpars_fixed = fixed_lpr)
```


We may alternately wish to update a patient's prior PK model after collecting measurements of plasma concentrations. This is done in a similar process as with BIS measurements and is illustrated below for a ten-minute period targeting an effect-site concentration of two $\mu$g/ml for the first five minutes and three $\mu$g/ml for the final five minutes with one sample collected each minute.


```{r, pk-update-example}
# update after 10 minutes of targeting 2 ug/ml for the first 5 minutes and 3 ug/ml for the second 5 minutes, with samples drawn each minute

# prior pk parameters for 1st patient in Eleveld dataset
pars_pk_prior <- unlist(eleveld_pop_prior[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0","LN_SIGMA")])

# true pk-pd parameters for patient
pars_pk_true <- unlist(eleveld_pop[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0","LN_SIGMA")])

# pass in values to be targeted at each time
inf <- tci(Ct    = c(2,3,3),
           tms   = c(0,5,10), 
           pkmod = pkmod3cptm,
           pars  = pars_pk_prior)

# plot infusion schedule with predicted concentrations
plot(inf)

# parameter estimates and prior mean/covariance
lpr_eval <- elvdlpars(eleveld_pop_prior[1,], pd = F)
mu0 <- elvdlpars(eleveld_pop[1,], pd = F)
sig0 <- poppk_cov("Eleveld", pd = F)

# simulate data based on true pk parameters
# generate observations every minute
set.seed(1)
dat <- gen_data(inf = inf, 
                tms = 1:10,
                pkmod = pkmod3cptm, 
                pars_pk0 = pars_pk_true, # true pk parameters
                sigma_add = eleveld_pop[1,"LN_SIGMA"], # random error
                log_err = TRUE,
                init = c(0,0,0,0))

post_est <- nlm(f = log_posterior_neg, 
                p = lpr_eval,
                dat = dat, 
                mu = mu0,
                sig = sig0,
                pd_ix = NULL, 
                err_ix = 10,
                hessian = T)

plot(dat, lpars_update = post_est$estimate)
```


As referenced earlier, repeated closed-loop control is implemented for PK-PD models through the function `bayes_control`. This function takes in 1) a data frame of targets and corresponding times at which the target is set, 2) the times at which updates should occur (with an optional specification of whether or not updates should use the full dataset or only the most recently collected observations), 3) a list of prior PK-PD model parameters and covariance matrix, and 4) a list of true PK-PD parameters. The function will default to using the Eleveld PK-PD model with an effect-site targeting TCI algorithm; however, these can be changed by the user.

We illustrate closed-loop control with BIS targets set by a sigmoid function over a five minute period with updates occurring each minute.

```{r, closed-loop, eval = TRUE, cache=TRUE}
# simulate for patient 1
id = 1
# prior parameters
eleveld_pop_prior <- eleveld_poppk(eleveld_pk[id,], rate = T, PD = T, rand = F)
pars_pk_prior <- unlist(eleveld_pop_prior[id,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_prior <- unlist(eleveld_pop_prior[id,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_prior) <- c("c50","gamma","gamma2","e0","emx")

# simulate true patient parameters
set.seed(1)
eleveld_pop <- eleveld_poppk(eleveld_pk[id,], rate = T, PD = T, rand = T)
pars_pk_true <- unlist(eleveld_pop[id,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_true <- unlist(eleveld_pop[id,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_true) <- c("c50","gamma","gamma2","e0","emx")

# list for prior distribution parameters
prior <- list(pars_pkpd = c(pars_pk_prior,pars_pd_prior),
              pk_ix = 1:9,
              fixed_ix = 11:14,
              err = eleveld_pop_prior[id,"SIGMA"],
              sig = poppk_cov("Eleveld"))

# list for prior distribution parameters
# information regarding which parameters should be updated is taken from prior object
true_pars <- list(pars_pkpd = c(pars_pk_true, pars_pd_true),
                  pk_ix = 1:9,
                  fixed_ix = 11:14,
                  err = eleveld_pop[id,"SIGMA"],
                  delay = eleveld_pop_prior[id,"BIS_DELAY"]/60)

# update after 10 minutes of following sigmoid targets with adjustments made every 10 seconds
# and BIS observations collected each second
starttm = 0; endtm = 10; dt_obs = 1/60; dt_tci = 1/6 
tms_sigmoid <- seq(starttm,endtm,dt_tci) # 10 minute induction with target sigmoid
targets <- data.frame(time = tms_sigmoid,
                      target =  emax(tms_sigmoid, restrict_sigmoid(1, BIS0 = 93)))

# specify times of updates and whether the full dataset should be used or only 
# the most recently collected samples - full updates for first three minutes, followed
# by partial updates for the remaining seven.
updates <- data.frame(time = 1:10, 
                      full_data = c(rep(TRUE,3), rep(FALSE,7)),
                      plot_progress = rep(c(FALSE,TRUE),5))

set.seed(2)
bayes_sim <- bayes_control(targets = targets, 
                           updates = updates,
                           prior = prior, 
                           true_pars = true_pars)
```


<!-- NOTE: at some point it may be useful to incorporate closed-loop control for PK models alone. This isn't done very frequently, but may at some time in the future if it becomes feasible to acquire concentration measurements from exhaled vapor.-->

Finally, we incorporate functions that will allow the user to optimize the set of TCI targets according to an objective function. The user specifies an objective function as well as a target function that will have its parameters optimized to minimize the objective function. The function could be as simple as a step function, in which the parameters optimized correspond directly to the TCI targets (e.g. a user could optimize the target BIS value for each minute during a 10 minute period), or it could correspond to a parameterized function (e.g. a linear, quadratic, or sigmoidal function) where the target is defined by the values of the function and its parameters are optimized. The latter case is useful for potentially drastically reducing the dimensionality of the optimization problem. 

The target function should be specified so as to translate a set of parameters and times into a series of infusions calculated to reach those targets according to a given TCI algorithm. The objective function should take a `tci_inf` object as its input and return a numeric value. Theses both can be passed on to the function `Phi_ED`, which will average the objective function over a population of interest. `Phi_ED` can then be optimized to provide a population-robust set of targets.

```{r, target-sigmoid-optimization}
# true pk-pd parameters for sample of patients
ix <- seq(1,nrow(eleveld_pop_prior), length.out = 20)
pars_pk_all <- as.matrix(eleveld_pop[ix,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_all <- as.matrix(eleveld_pop[ix,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_all) <- c("c50","gamma","gamma2","e0","emx")

# optimize objective function and target function over population
Phi_ED(lp = log(1), 
       targetfn = sigmoid_targetfn, 
       tms = seq(0,10,1/6),
       Phi = Phi_WgtOvershoot, 
       pars_pk_all = pars_pk_all,
       pars_pd_all = pars_pd_all)
```






