---
title: "Selected examples using the TCI package"
author: "Ryan Jarrett"
date: "2/18/2020"
output: github_document
---

```{r setup, include=FALSE}
library(knitr)
library(pander)
library(microbenchmark)

# setwd("~/tci")
knitr::opts_chunk$set(echo = T, message = F, warning = F, fig.align="center")
```

## Infusion objects

The package structure allows for the creation of infusion objects that are passed on to any specified PK or PK-PD model. The user can specify a dataframe with times and infusion rates expressed in terms of mL or mg. Infusion objects are returned as lists of piece-wise infusions in terms of mg/m. Unless otherwise specified, it is assumed that the infusions start at time $t=0$. 

The example below creates an infusion object with a rate of 1000 mL/h from time $t=0.5$ to $t=3.5$ minutes, followed by an infusion of rate 250 mL/h until time $t=8.5$ minutes. 

```{r, inf-base}
#' Function to create an infusion object from a dosing schedule with infusion rates provided
inf_base <- function(d, unit = c("mg","mL"), tm_unit = c("m","h"), mgpermL = 10, starttm = 0){

  unit <- match.arg(unit)
  tm_unit <- match.arg(tm_unit)
  rt <- d$infrt

  if(unit == "mL") rt <- rt*mgpermL
  if(tm_unit == "h") rt <- rt / 60

  tms <- c(starttm, d$time)
  
  return(lapply(1:length(rt), function(k) list(begin = tms[k], end = tms[k+1], k_R = rt[k])))
}
 
dose <- data.frame(time = c(0.5,3.5,8.5), infrt = c(0,1000,250))
inf_base(dose, unit = "mL", tm_unit = "h")
```


We would also like to be able to create infusion objects based on a set of target concentrations to be used by TCI algorithms. Since TCI algorithms check the target with a regular frequency, we create a function to expand the set of target infusions into one separated into regular time periods. 

Here the user specifies target plasma concentrations (`Cpt`) of $(0,2,1)$ for the time intervals, with the expectation that the TCI algorithm will update its target every 10 seconds (1/6 of a minute). The infusions are left-continuous, such that the final infusion finishes at the last time specified with no new infusion beginning at the final time.

```{r, expand-inf}
#' Function to expand time / target dataframe to be passed on to TCI algorithm
expand_infs <- function(d, starttm = 0, freq = 1/6, val_name = NULL){
  library(plyr)
  if(is.null(val_name)) val_name <- try(match.arg(c("Cpt","Cet","BIS"), names(d), several.ok = T), silent = T)
  if(class(val_name) == "try-error") stop('Dataframe d requires the target name column to be one of c("Cpt","Cet","BIS") or specified through the val_name argument')
  schd <- data.frame(start = c(starttm, head(d$time,-1)), end = d$time, d[val_name], freq = freq)
  rbind(arrange(ddply(schd, val_name, summarise, time = seq(start, end-freq, by = freq)), time), c(NA,tail(d$time,1)))
}

ds <- data.frame(time = c(0.5,3.5,8.5), Cpt = c(0,2,1))
head(expand_infs(ds))
```



## PK models

For illustration, we consider two PK models with IV infusions: a one-compartment model, and a three-compartment model with an effect-site compartment. 

The functions below gives the predicted concentrations in each compartment for both models associated with a continuous infusion of 1 mg/m over five minutes.

```{r, pk-1cpt}
pkmod1cpt <- function(tm, kR, pars, init = 0, inittm = 0){

  if(!all(hasName(pars, c("ke","v"))) & !all(hasName(pars, c("CL","v")))) stop('pars must have names "ke","v" or "CL","v"')
  tm <- tm - inittm

  list2env(as.list(pars), envir = environment())

  if("CL" %in% ls())
    ke <- CL / v

  return((kR/ke*(1-exp(-tm*ke)) + init*v * exp(-tm*ke)) / v)
}
class(pkmod1cpt) <- "pkmod"

tms <- seq(0,5,0.1)
pars_1cpt <- c(ke = 0.1, v = 10)
plot(tms, pkmod1cpt(tm = tms, kR = 1, pars = pars_1cpt, init = 0), type = "l", xlab = "min", ylab = "Cp")
```

```{r, pk-3cpt}
pkmod3cptm <- function(tm, kR, pars, init = c(0,0,0,0), inittm = 0, returncpt = c("all","cpt1","cpt2","cpt3","cpt4")) {

  list2env(as.list(pars), envir = environment())
  returncpt <- match.arg(returncpt)
  tm <- tm - inittm

  if(!("k20" %in% ls())){
    k20 <- 0
  }
  if(!("k30" %in% ls())){
    k30 <- 0
  }

  kme <- ke0 # k41
  km  <- kme / 1e5 # k14 Absorption into the effect site is much slower than elimination --> as soon as any drug enters, it is eliminated
  v4  <- v1 / 1e5
  # km = 0
  # v4 = 0
  E1 <- k10+k12+k13+km
  E2 <- k21+k20
  E3 <- k31+k30

  a <- E1+E2+E3
  b <- E1*E2+E3*(E1+E2)-k12*k21-k13*k31
  c <- E1*E2*E3-E3*k12*k21-E2*k13*k31

  m <- (3*b - a^2)/3
  n <- (2*a^3 - 9*a*b + 27*c)/27
  Q <- (n^2)/4 + (m^3)/27

  alpha <- sqrt(-1*Q)
  beta <- -1*n/2
  gamma <- sqrt(beta^2+alpha^2)
  theta <- atan2(alpha,beta)

  lambda1 <- a/3 + gamma^(1/3)*(cos(theta/3) + sqrt(3)*sin(theta/3))
  lambda2 <- a/3 + gamma^(1/3)*(cos(theta/3) - sqrt(3)*sin(theta/3))
  lambda3 <- a/3 -(2*gamma^(1/3)*cos(theta/3))

  A1last <- init[1]*v1
  A2last <- init[2]*v2
  A3last <- init[3]*v3
  Amlast <- init[4]*v4

  B = A2last*k21+A3last*k31
  C = E3*A2last*k21+E2*A3last*k31
  I = A1last*k12*E3-A2last*k13*k31+A3last*k12*k31
  J = A1last*k13*E2+A2last*k13*k21-A3last*k12*k21

  if(returncpt %in% c("all", "cpt1")){
    A1term1 = A1last*(exp(-tm*lambda1)*(E2-lambda1)*(E3-lambda1)/((lambda2-lambda1)*(lambda3-lambda1))+exp(-tm*lambda2)*(E2-lambda2)*(E3-lambda2)/((lambda1-lambda2)*(lambda3-lambda2))+exp(-tm*lambda3)*(E2-lambda3)*(E3-lambda3)/((lambda1-lambda3)*(lambda2-lambda3)))
    A1term2 = exp(-tm*lambda1)*(C-B*lambda1)/((lambda1-lambda2)*(lambda1-lambda3))+exp(-tm*lambda2)*(B*lambda2-C)/((lambda1-lambda2)*(lambda2-lambda3))+exp(-tm*lambda3)*(B*lambda3-C)/((lambda1-lambda3)*(lambda3-lambda2))
    A1term3 = kR*((E2*E3)/(lambda1*lambda2*lambda3)-exp(-tm*lambda1)*(E2-lambda1)*(E3-lambda1)/(lambda1*(lambda2-lambda1)*(lambda3-lambda1))-exp(-tm*lambda2)*(E2-lambda2)*(E3-lambda2)/(lambda2*(lambda1-lambda2)*(lambda3-lambda2))-exp(-tm*lambda3)*(E2-lambda3)*(E3-lambda3)/(lambda3*(lambda1-lambda3)*(lambda2-lambda3)))
    A1term = A1term1+A1term2+A1term3
  } else A1term = NULL


  if(returncpt %in% c("all", "cpt2")){
    A2term1 = A2last*(exp(-tm*lambda1)*(E1-lambda1)*(E3-lambda1)/((lambda2-lambda1)*(lambda3-lambda1))+exp(-tm*lambda2)*(E1-lambda2)*(E3-lambda2)/((lambda1-lambda2)*(lambda3-lambda2))+exp(-tm*lambda3)*(E1-lambda3)*(E3-lambda3)/((lambda1-lambda3)*(lambda2-lambda3)))
    A2term2 = exp(-tm*lambda1)*(I-A1last*k12*lambda1)/((lambda1-lambda2)*(lambda1-lambda3))+exp(-tm*lambda2)*(A1last*k12*lambda2-I)/((lambda1-lambda2)*(lambda2-lambda3))+exp(-tm*lambda3)*(A1last*k12*lambda3-I)/((lambda1-lambda3)*(lambda3-lambda2))
    A2term3 = kR*k12*(E3/(lambda1*lambda2*lambda3)-exp(-tm*lambda1)*(E3-lambda1)/(lambda1*(lambda2-lambda1)*(lambda3-lambda1))-exp(-tm*lambda2)*(E3-lambda2)/(lambda2*(lambda1-lambda2)*(lambda3-lambda2))-exp(-tm*lambda3)*(E3-lambda3)/(lambda3*(lambda1-lambda3)*(lambda2-lambda3)))
    A2term = A2term1+A2term2+A2term3
  } else A2term = NULL


  if(returncpt %in% c("all", "cpt3")){
    A3term1 = A3last*(exp(-tm*lambda1)*(E1-lambda1)*(E2-lambda1)/((lambda2-lambda1)*(lambda3-lambda1))+exp(-tm*lambda2)*(E1-lambda2)*(E2-lambda2)/((lambda1-lambda2)*(lambda3-lambda2))+exp(-tm*lambda3)*(E1-lambda3)*(E2-lambda3)/((lambda1-lambda3)*(lambda2-lambda3)))
    A3term2 = exp(-tm*lambda1)*(J-A1last*k13*lambda1)/((lambda1-lambda2)*(lambda1-lambda3))+exp(-tm*lambda2)*(A1last*k13*lambda2-J)/((lambda1-lambda2)*(lambda2-lambda3))+exp(-tm*lambda3)*(A1last*k13*lambda3-J)/((lambda1-lambda3)*(lambda3-lambda2))
    A3term3 = kR*k13*(E2/(lambda1*lambda2*lambda3)-exp(-tm*lambda1)*(E2-lambda1)/(lambda1*(lambda2-lambda1)*(lambda3-lambda1))-exp(-tm*lambda2)*(E2-lambda2)/(lambda2*(lambda1-lambda2)*(lambda3-lambda2))-exp(-tm*lambda3)*(E2-lambda3)/(lambda3*(lambda1-lambda3)*(lambda2-lambda3)))
    A3term = A3term1+A3term2+A3term3
  } else A3term = NULL

  if(returncpt %in% c("all", "cpt4")){
    Amterm1 = Amlast*exp(-tm*kme) +km*A1last*(exp(-tm*lambda1)*(E2-lambda1)*(E3-lambda1)/((lambda2-lambda1)*(lambda3-lambda1)*(kme-lambda1))+exp(-tm*lambda2)*(E2-lambda2)*(E3-lambda2)/((kme-lambda2)*(lambda1-lambda2)*(lambda3-lambda2))+exp(-tm*lambda3)*(E2-lambda3)*(E3-lambda3)/((kme-lambda3)*(lambda1-lambda3)*(lambda2-lambda3))+exp(-tm*kme)*(E2-kme)*(E3-kme)/((lambda1-kme)*(lambda2-kme)*(lambda3-kme)))
    Amterm2 = km*(exp(-tm*lambda1)*(B*lambda1-C)/((lambda1-lambda2)*(lambda1-lambda3)*(lambda1-kme))+exp(-tm*lambda2)*(C-B*lambda2)/((lambda1-lambda2)*(lambda2-lambda3)*(lambda2-kme))+exp(-tm*lambda3)*(C-B*lambda3)/((lambda1-lambda3)*(lambda3-lambda2)*(lambda3-kme))-exp(-tm*kme)*(B*kme-C)/((lambda1-kme)*(kme-lambda2)*(kme-lambda3)))
    Amterm3 = km*kR*((E2*E3)/(lambda1*lambda2*lambda3*kme)-exp(-tm*lambda1)*(E2-lambda1)*(E3-lambda1)/(lambda1*(kme-lambda1)*(lambda2-lambda1)*(lambda3-lambda1))-exp(-tm*lambda2)*(E2-lambda2)*(E3-lambda2)/(lambda2*(kme-lambda2)*(lambda1-lambda2)*(lambda3-lambda2))-exp(-tm*lambda3)*(E2-lambda3)*(E3-lambda3)/(lambda3*(kme-lambda3)*(lambda1-lambda3)*(lambda2-lambda3))-exp(-tm*kme)*(E2-kme)*(E3-kme)/(kme*(lambda1-kme)*(lambda2-kme)*(lambda3-kme)))
    Amterm = Amterm1+Amterm2+Amterm3
  } else Amterm = NULL

  return(rbind(A1term/v1, A2term/v2, A3term/v3, Amterm/v4))

}
class(pkmod3cptm) <- "pkmod"

pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
con <- pkmod3cptm(tm = tms, kR = 1, pars = pars_3cpt, init = c(0,0,0,0))
plot(tms, tms, type = "n", ylim = range(con), ylab = "concentration (mg/mL)", xlab = "min")
sapply(1:nrow(con), function(i) lines(tms, con[i,], col = i)); legend("topleft", paste("compartment",1:4), col = 1:4, lty = 1, cex = 0.8)
```



We need to be able to extend each PK function to any arbitrary infusion schedule, which we do by applying the function to each infusion in succession and using the final predicted concentrations as the starting point for the subsequent infusion. 

As an example, we apply both PK models to the infusion schedule specified at the beginning.

```{r, predict-pkmod}
# function to extract the last 
tail_vec <- function(...){
  args <- list(...)[[1]]
  if(is.null(dim(args)))
    return(tail(args,1))
  c(tail(t(args),1))
}
tail_vec(1:8); tail_vec(matrix(1:8,2,4))


# dosing schedule
create_intvl <- function(dose, starttm = 0){
  b <- cut(dose$time, breaks = c(starttm,dose$time), include.lowest = TRUE, right = FALSE)
  ss <- t(sapply(stringr::str_extract_all(levels(b),"-?[0-9.]+"), as.numeric))
  setNames(data.frame(levels(b), dose$infrt, ss), c("intvl","infrt","begin","end"))
}
dose <- data.frame(time = c(0.5,4,4.5,10), infrt = c(100,0,100,0))
create_intvl(dose)

# sequence function that includes bounds and optional extra points
seqby <- function(from, to, by)
  sort(union(seq(from, to, by), c(from, to)))

seq(0,0.767,1/6)
seqby(0,0.767,1/6)


# predict method to apply pk model piecewise to infusion schedule
predict <- function (pkmod, ...) {UseMethod("predict", pkmod)}

predict.pkmod <- function(pkmod, inf, tms = NULL, dt = 1/6, len_out = NULL, return_init = FALSE, remove_bounds = TRUE, ...){

  pred <- vector("list", length(inf$infrt))
  init <- vector("list", length(inf$infrt)+1)

  # Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dt.
  if(!is.null(tms)){
    b <- unique(as.numeric(unlist(stringr::str_extract_all(inf$intvl,"-?[0-9.]+"))))
    tms_all <- unique(sort(c(b,tms)))
    # tms_eval <- split(tms_all, cut(tms_all, breaks = b, right = T))
    tms_eval <- split(tms_all, findInterval(tms_all, b, rightmost.closed = T, left.open = T))
  } else{
    if(is.null(len_out)) tms_eval <- mapply(seqby, inf$begin+dt, inf$end, by = dt, SIMPLIFY = F)
    else tms_eval <- mapply(seq, inf$begin+dt, inf$end, length.out = len_out)
  }

  # Pass on initial concentrations to first element of init. Use values if specified, else defaults.
  dot.args <- list(...)
  if("init" %in% names(dot.args)){ 
    init[[1]] <- dot.args$init
    dot.args$init <- NULL
  } else { 
    init[[1]] <- eval(formals(pkmod)$init)
  }
  
  # Predict concentrations and store initial values.
  for(i in 1:nrow(inf)){
    pred[[i]] <- do.call("pkmod", c(list(tm = tms_eval[[i]], kR = inf$infrt[i], init = init[[i]], inittm = inf$begin[i]), dot.args))
    init[[i+1]] <- tail_vec(pred[[i]]) # extract last element OR column
  }

  # Return predicted concentrations
  if(is.null(dim(pred[[1]]))) {
    predtms <- cbind(unique(unlist(tms_eval)),  do.call("c", pred))
  } else{
    predtms <- cbind(unique(unlist(tms_eval)),  t(do.call("cbind", pred)))
  }

  # Add on t=0 concentrations
  if(return_init) predtms <- rbind(c(inf$begin[1], init[[1]]), predtms)

  # remove transition concentrations
  if(!is.null(tms) & remove_bounds) predtms <- matrix(predtms[which(predtms[,1] %in% tms),], nrow = length(tms), byrow = F)
  
  colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
  return(predtms)
}

# predict for 1cpt model
head(predict(pkmod = pkmod1cpt, inf = create_intvl(dose), pars = pars_1cpt, init = 2, return_init = T))
# predict for 3cpt model
head(predict(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt, return_init = T))
# predict for 3cpt model at specific values
head(predict(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt, tms = c(1,2,3)))
```


<!-- We also create wrapper functions to evaluate the PK model at the transition point. -->

<!-- ```{r, begin-end-vals} -->
<!-- begin_vals <- function(pkmod, inf, ...) -->
<!--   cbind(inf, predict(pkmod, inf, tms = inf$begin, return_init = T, ...)[1:length(inf$begin),-1]) -->

<!-- end_vals <- function(pkmod, inf, ...) -->
<!--   cbind(inf, predict(pkmod, inf, tms = inf$begin, return_init = F, ...)[,-1]) -->

<!-- begin_vals(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt) -->
<!-- end_vals(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt) -->
<!-- ``` -->


Finally, we create a plot method for PK models with set infusions. 

```{r, plot-method}
plot <- function(pkmod, ...) {UseMethod("plot", pkmod)}

library(ggplot2)
library(reshape) 

# Note: ... arguments SHOULD be passed to plotting function instead of predict. Will fix later. 
plot.pkmod <- function(pkmod, inf, npts = 1000, title = NULL, ...){
  
  # set dt based on range between points
  dt <- diff(range(inf$begin, inf$end)) / npts
  # predict concentrations
  con <- data.frame(predict(pkmod, inf, dt = dt, return_init = T, ...))

  ggplot(melt(con, id = "time"), aes(x = time, y = value, linetype = variable, color = variable)) + 
    geom_line() + 
    labs(y = "Concentration", x = "Time", color = "Compartment", linetype = "Compartment", title = title)
}

plot(pkmod = pkmod1cpt, inf = create_intvl(dose), pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
plot(pkmod = pkmod3cptm, inf = create_intvl(dose), pars = pars_3cpt, title = "Concentrations for a 3 compartment model with an effect site")
```


## Target-controlled infusion (TCI) algorithms

All TCI algorithms are expected to take in a target concentration value, a PK model, and the duration of the infusion administered. Additional arguments specifying aspects such as the maximum infusion rate or the target compartment may be provided. When users want to supply a custom TCI algorithm, they will write an algorithm such as the one above that returns an infusion for a single target, as well as the amount of time required to do so. Later on we will provide a function that extends any TCI algorithm to multiple targets. 

The algorithm below makes use of the approximate linearity in plasma concentrations associated with a continuous infusion and returns the infusion required to reach the target if administered for a duration of `dt`.

```{r, plasma-tci}
tci_plasma <- function(Cpt, pkmod, dt, maxrt = 10000, cmpt = 1, ...){

  Cp1 <- pkmod(tm = dt, kR = 1, ...)
  Cp2 <- pkmod(tm = dt, kR = 2, ...)
  
  # for multi-compartment models, use only concentration in compartment 'cmpt'
  if(!is.null(dim(Cp1))){
    Cp1 <- Cp1[1,]
    Cp2 <- Cp2[1,]
  }
  
  m <- Cp2 - Cp1
  b <- Cp1 - m
  infrt <- (Cpt - b) / m
  if(infrt < 0)
    infrt <- 0
  if(infrt > maxrt)
    infrt <- maxrt
  return(c(kR = infrt, dt = dt))
}

# find infusion to increase plasma concentration to 2 within 2 minutes.
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod1cpt, pars = pars_1cpt) 
# verify that infusion will reach target at 2 minutes
pkmod1cpt(tm = 2, pars = pars_1cpt, kR = inf_est[1])
plot(pkmod1cpt, pars = pars_1cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est[1],0))), 
     title = "Infusion required to reach a plasma concentration of 2")

# test for 3 compartment model with initial concentrations
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0)) 
pkmod3cptm(tm = 2, pars = pars_3cpt, kR = inf_est[1], init = c(1,0,0,0))
plot(pkmod3cptm, pars = pars_3cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est[1],0))), 
     init = c(1,0,0,0), title = "Infusion required to reach a plasma concentration of 2 in a 3cmpt model")
```


Now, we also create an effect-site TCI algorithm. This algorithm returns the infusion that, if administerd for a duration of `dt`, will reach the effect-site target in the minimum amount of time without overshoot.


```{r, effect-site-tci}
tci_effect <- function(Cet, pkmod, dt = 1/6, max_kR = 10000, cmpt_name = "c4", tmax_search = 20, maxrt = 200, grid_len = 1200, ...){
  
  list2env(list(...), envir = environment())
  if(is.null(init)) init <- eval(formals(pkmod)$init)
  if(is.null(pars)) pars <- try(eval(formals(pkmod)$pars), silent = T)
  if(class(pars) == "try-error") stop("PK parameters must either be provided as arguments to the TCI algorithm or as defaults to the PK model.")
  
  # infusions corresponding to unit infusion for duration and a null infusion
  unit_inf <- create_intvl(data.frame(time = c(dt, tmax_search), infrt = c(1,0)))
  null_inf <- create_intvl(data.frame(time = tmax_search, infrt = 0))
  
  # predict concentrations with no additional infusions
  B <- function(tm)
    predict(pkmod, inf = null_inf, pars = pars, init = init, tms = tm)[,cmpt_name]
  
  # predict concentrations with no additional infusions
  E <- function(tm)
    predict(pkmod, inf = unit_inf, pars = pars, init = rep(0,length(init)), tms = tm)[,cmpt_name]
  
  # predict to find the longest time of maximum concentration -- will always be shorter when any prior drug has been infused.
  grid_tmax <- seq(0,tmax_search,length.out = grid_len)
  con_proj <- E(grid_tmax)
  peak_ix <- which.max(con_proj)
  con_peak <- con_proj[peak_ix]
  tpeak <- grid_tmax[peak_ix]
  
  if(all(init == 0)){
    kR <- Cet / con_peak
  } else{
    tms <- seq(0, tpeak+0.5, length.out = grid_len)
    jpeak0 = tpeak - 0.1 
    jpeak1 = jpeak0 + 0.1
    
    while(jpeak0 != jpeak1){
      jpeak0 = jpeak1
      I0 = (Cet - B(jpeak0)) / E(jpeak0)
      ceproj = B(tms) + E(tms)*I0
      jpeak1 = tms[which.max(ceproj)]
    }
    
    kR = unname((Cet-B(jpeak1)) / E(jpeak1))
  }
  
  if(kR < 0) kR = 0
  if(kR > max_kR) kR = max_kR
  
  return(kR)
}  

# calculate the 10 second infusion rate required to reach a concentration of 1 ug/ml in the effect-site compartment with existing drug in the first compartment. 
kR_Cet <- tci_effect(Cet = 1, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0), dt = 1/6)
inf <- create_intvl(data.frame(time = c(1/6, 20), infrt = c(kR_Cet,0)))
plot(pkmod3cptm, inf, pars = pars_3cpt, init = c(1,0,0,0), 
     title = "10-sec infusion to reach a Cet of 1 in a 3cmpt model with initial cons")

# The algorithm may also be used to specify target different compartments, if desired. 
# Find 1 minute infusion required to reach a concentration of 0.5 in compartment 2 with no prior infusions. 
infdt = 1
kR_Cet_cmpt2 <- tci_effect(Cet = 0.5, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(0,0,0,0), dt = infdt, cmpt_name = "c2")
inf_cmpt2 <- create_intvl(data.frame(time = c(infdt, 20), infrt = c(kR_Cet_cmpt2,0)))
plot(pkmod3cptm, inf_cmpt2, pars = pars_3cpt, init = c(0,0,0,0),
     title = "1-min infusion to reach a c2 con of 0.5 in a 3cmpt model")
```


We now need a function to iterate any arbitrary TCI algorithm across a series of targets. By default, the function will update infusion rates at fixed intervals (e.g. every 10 seconds); however, users will have the option of waiting only calculating infusions after the prior target has been obtained. 

The user passes the `iterate_tci` function a matrix of target concentrations and times at which the target is set. This is translated into a step function that defines the concentration target at all times. 

<!-- If desired, the user may also pass on an update model parameters function at each target change.  -->

1. Set up target concentration function.
  - The function should be left-continuous, such that each (time, Cet) combination defines the target at that time. The function will calculate infusions until the end of the time period defined.
2. Define update schedule (to extent possible). Define vector of tci evaluation times (if possible), infusion durations
  - May require function for finding and maintaining a constant infusion rate (numerically? Since it may not be possible for any arbitrary PK model)

```{r, iterate-tci}
iterate_tci_grid <- function(Cet, tms, tci, pkmod, pars, init = NULL, starttm = 0, dt = 1/6, ...){
  
  # adjust times such that infusions start at tm = 0
  tms <- tms - starttm
  
  # create step function to define targets at any point
  sf <- stepfun(tms, Cet)
  
  # define sequence of update times
  updatetms <- seq(0, max(tms), dt)
  
  ncpt <- length(eval(formals(pkmod)$init))
  if(is.null(init)) init <- rep(0,ncpt)
  inf <- matrix(NA, nrow = length(updatetms), ncol = 2)
  ini <- matrix(NA, nrow = ncpt, ncol = length(updatetms)+1)
  ini[,1] <- init
  
  # iterate through times
  for(i in 1:length(updatetms)){
    inf[i,] <- tci(sf(updatetms[i]), pkmod = pkmod, pars = pars, dt = dt, init = ini[,i], ...)
    ini[,i+1] <- pkmod(tm = dt, kR = inf[i,1], pars = pars, init = ini[,i])
  }
  
  startcon <- data.frame(matrix(ini[,-ncol(ini)], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
  endcon <- data.frame(matrix(ini[,-1], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
  out <- as.data.frame(cbind(inf, starttm = updatetms, startcon, endcon))
  names(out) <- c("inf","dt","starttm", paste0("c",1:ncpt, "_start"), paste0("c",1:ncpt, "_end"))
  return(out)
}

tms <- c(5,10,15)
Cet <- c(2,1.5,1,1)
plot(stepfun(tms, Cet), ylim = c(0,2), xlim = c(0,15), main = "Plasma-targeting TCI algorithm", xlab = "min", ylab = "concentration")

# one compartment model
tci_1cpt <- iterate_tci_grid(Cet, tms, tci = tci_plasma, pkmod = pkmod1cpt, pars = pars_1cpt)
lines(tci_1cpt$starttm, tci_1cpt$c1_start, col = 2)

# three compartment model
tci_3cpt <- iterate_tci_grid(Cet, tms, tci = tci_plasma, pkmod = pkmod3cptm, pars = pars_3cpt)
lines(tci_3cpt$starttm, tci_3cpt$c1_start, col = 3)

legend("bottomright", c("One compartment", "Three compartments"), lty = c(1,1), col = c(2,3), cex = 0.8)


# effect-site targeting
tci_3cpt_effect <- iterate_tci_grid(Cet, tms, tci = tci_effect, pkmod = pkmod3cptm, pars = pars_3cpt)

plot(stepfun(tms, Cet), ylim = c(0,7), xlim = c(0,15), main = "Plasma-targeting TCI algorithm", xlab = "min", ylab = "concentration")
lines(tci_3cpt_effect$starttm, tci_3cpt_effect$c1_start, col = 2)
lines(tci_3cpt_effect$starttm, tci_3cpt_effect$c4_start, col = 3)
legend("topright", c("Plasma", "Effect site"), lty = c(1,1), col = c(2,3), cex = 0.8)


# effect-site targeting with initial concentrations
tci_3cpt_effect_init <- iterate_tci_grid(Cet, tms, tci = tci_effect, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(2,0,0,2))

plot(stepfun(tms, Cet), ylim = c(0,3), xlim = c(0,15), main = "Plasma-targeting TCI algorithm", xlab = "min", ylab = "concentration")
lines(tci_3cpt_effect_init$starttm, tci_3cpt_effect_init$c1_start, col = 2)
lines(tci_3cpt_effect_init$starttm, tci_3cpt_effect_init$c4_start, col = 3)
legend("topright", c("Plasma", "Effect site"), lty = c(1,1), col = c(2,3), cex = 0.8)
```












