---
title: "Introduction to tci package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to tci package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bibfile.bib  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE, 
  message = FALSE, 
  warning = FALSE, 
  fig.align="center",
  fig.height= 4, 
  fig.width = 6
)
```

## Introduction

Target-controlled infusion (TCI) systems calculate infusion rates required to reach target concentrations or effects within a patient. Where pharmacokinetic (PK) and pharmacodynamic (PD) models describe a time course of concentrations or effects, respectively, associated with a series of doses, TCI algorithms calculate the inverse relationship: what doses must be administered to achieve target responses? 

The `tci` package implements TCI algorithms for PK and PK-PD models for drugs described by compartmental models and administered via intravenous infusion. The package provides closed solutions for one, two, or three compartment mammillary models (i.e., all peripheral compartments are joined to a central compartment), as well as a three-compartment model with an adjoining effect-site. PK model code is based on solutions and code published by @Abuhelwa2015. TCI algorithms for plasma- and effect-site targeting are implemented based on work by @Jacobs1990 and @Shafer1992, respectively. Users can specify alternative PK models or TCI algorithms.



```{r, libraries}
library(tci)
library(ggplot2)   # ggplot for plotting
library(gridExtra) # arrangeGrob to arrange plots
library(reshape2)  # melt function
```

```{r, echo=FALSE, eval = FALSE}
old <- theme_set(theme_bw())
ggplot <- function(...) ggplot2::ggplot(...) + 
  scale_color_brewer(palette="Pastel1")
  # scale_color_manual(values = c("black","steelblue","seagreen"))
```

## `pkmod` object class

The `tci` package is built around the use of objects with the S3 class `pkmod` created with the function `pkmod`. These serve as containers for 1) functions implementing the structural PK model (e.g., a 1-compartment model with first-order elimination) and the PD model, if applicable, 2) the parameters for the respective functions, and 3) initial concentrations, and 4) information relevant for simulating observations or implementing TCI control, such as the compartment number associated with observations or with an effect-site. If unspecified, it will assume that the first compartment corresponds to plasma measurements and the final compartment is the effect-site.

For use of compartment models included within the package (i.e., 1-,2-,3-compartment or 3-effect), the structural PK model can be inferred from the parameter names. 

```{r}
# 1-compartment model
(mod1cpt <- pkmod(pars_pk = c(cl = 10, v = 15)))
# 3-compartment model with effect site
(mod3ecpt <- pkmod(pars_pk = c(cl = 10, q2 = 2, q3 =20, v = 15, v2 = 30, v3 = 50, ke0 = 1.2)))
```

The list of usable parameter names can be seen by typing `list_parnms()`. 
```{r}
# acceptable parameter names
list_parnms()
```

Elements of `pkmod` objects can be modified through an `update.pkmod` method. Perhaps most usefully, this allows for partial modifications to PK-PD parameters. For example, the effect-site equilibrium constant can be easily updated.

```{r}
update(mod3ecpt, pars_pk = c(ke0 = 0.9), init = c(1,0.2,0.3,1))
```

Most functions in the `tci` package pass additional arguments to `update.pkmod` allowing for easy modification of `pkmod` objects as needed.


## Infusion schedules

An infusion schedule is required to evaluate a `pkmod` object. This schedule should be a matrix with column labels "begin", "end", and "infrt", indicating infusion begin times, end times, and infusion rates. It can be created directly by the user, or outputted by the `create_inf` or `apply_tci` functions. In the former function, the user specifies infusion start times, durations, and infusion rates. 

```{r}
# single infusion
(single_inf <- create_inf(times = 0, duration = 0.5, infrt = 100))
# multiple infusions
(multi_inf <- create_inf(times = c(0,3,6), duration = c(1,0.5,0.25), infrt = 100))
```

Typically, however, the `apply_tci` will be used to calculate infusion rates required to reach specified targets. `apply_tci` requires 1) a set of target concentrations (or PD response values) and corresponding times at which the target is set, and 2) a `pkmod` object. It has "plasma" and "effect" settings, implementing the Jacobs and Shafer algorithms, respectively. Custom algorithms can be specified through the `custom_alg` argument.

```{r}
# target concentrations for TCI algorithm
targets <- cbind(value = c(2,3,4,4), time = c(0,2,3,10))

# plasma targeting for one-compartment model
inf_1cpt <- apply_tci(targets, pkmod = mod1cpt, type = "plasma")
head(inf_1cpt)

# effect-site targeting for three-compartment effect site model
inf_3ecpt <- apply_tci(targets, pkmod = mod3ecpt, type = "effect")
head(inf_3ecpt)
```

By default, plasma- and effect-targeting algorithms are updated in increments of 1/6. If a PK model elimination parameters have units of minutes (as do commonly used models for the anesthetic propofol), this will correspond to updating TCI targets at 10-second intervals. If elimination rates are in different units, such as hours, then the TCI update frequency should be modified using the `apply_tci` argument `dtm`.

## Predict and simulate methods

The infusion schedule can be applied to the `pkmod` object using `predict.pkmod` or `simulate.pkmod` methods to predict concentrations or simulate observations, respectively. Using the three-compartment model as illustration

```{r}
# prediction/observation times
tms_pred <- seq(0,10,0.01)
tms_obs <- c(0.5,1,2,4,6,10)

pre <- predict(mod3ecpt, inf = inf_3ecpt, tms = tms_pred)
obs <- simulate(mod3ecpt, seed = 1, inf = inf_3ecpt, tms = tms_obs, sigma_mult = 0.2)

# plot results
dat <- data.frame(time = tms_pred, `plasma (3 cmpt)` = pre[,"c1"], 
                  `effect (ke0=1.2)` = pre[,"c4"],
                  check.names = FALSE)
datm <- melt(dat, id = "time")
dat_obs <- data.frame(time = tms_obs, con = obs, variable = "plasma (3 cmpt)")

p <- ggplot(datm, aes(x = time, y = value, color = variable)) + 
  geom_line() + 
  geom_point(data = dat_obs, aes(x = time, y = con)) +
  xlab("Minutes") + ylab("Concentration (mg/L)")
p
```

Notably, the `pkmod` object used in the predict and simulate methods does not need to be the same as the one used to calculate the infusion schedule. This permits the user to evaluate the effect of model misspecification either 1) by passing different parameter values to `update.pkmod` via `predict.pkmod` or `simulate.pkmod`, or 2) by using a different `pkmod` object. 

To illustrate the parameter misspecification, we can evaluate predictions with a new effect-site equilibrium constant.

```{r}
# evaluate with different ke0 parameter
pre_misspec <- predict(mod3ecpt, inf = inf_3ecpt, tms = tms_pred, 
                       pars_pk = c(ke0 = 0.8))
dat_misspec <- data.frame(pre_misspec, variable = "effect (ke0=0.8)", time = tms_pred)
p + geom_line(data = dat_misspec, aes(x = time, y = c4, color = variable))
```

To illustrate structural model misspecification, we can consider the case where PK are described by a one-compartment model, but infusions were calculated according to a three-compartment model.

```{r}
# predicted concentrations
pre_1cpt <- predict(mod1cpt, inf = inf_3ecpt, tms = tms_pred)
dat_1cpt <- data.frame(pre_1cpt, variable = "plasma (1 cmpt)", time = tms_pred)
# simulated observations
obs_1cpt <- simulate(mod1cpt, seed = 1, inf = inf_3ecpt, tms = tms_obs, sigma_mult = 0.2)

p + geom_line(data = dat_1cpt, aes(x = time, y = c1, color = variable)) +
  geom_point(data = data.frame(time = tms_obs, con = obs_1cpt, variable = "plasma (1 cmpt)"), 
           aes(x = time, y = con), inherit.aes = FALSE, color = "green4")
```


## Extensions to PK-PD models

All of the functions in `tci` can be extended to include pharmacodynamic (PD) models. Unlike PK models, the equations describing PD models are typically invertible, allowing one to readily calculate the target effect-site concentration associated with a desired effect. The user, therefore, supplies to a `pkmod` functions implementing the PD response (i.e., compute response from concentrations), and its inverse (i.e., concentrations from a response), as well as associated parameter values.

Four-parameter E-max models are commonly used to describe PD responses and are implemented in `tci`. E-max models describe a response in terms of its minimum and maximum values, `emx` and `e0`, respectively, the concentration associated with 50\% effect, `c50`, and the slope of the dose-response curve at c50, `gamma`. In anesthesia, the Bispectral Index (BIS) is a commonly used measurement of a patient's depth of hypnosis and is often described by an E-max model. BIS is derived from EEG measurements and calibrated to vary between BIS=100, indicating a fully-alert state, and BIS=0, in which little brain activity is registered. BIS values between 40 and 60 typically indicate that a patient is sufficiently sedated for general anesthesia.

```{r}
modpd <- update(mod3ecpt, pdfn = emax, pdinv = emax_inv, 
                 pars_pd = c(e0 = 100, emx = 100, c50 = 3.5, gamma = 2.2))
```

PD targets are passed along with the updated `pkmod` to `apply_tci`, which will assume values are PD values (unless overridden by the `ignore_pd` argument of `apply_tci`).

```{r}
pd_targets <- cbind(value = c(70,60,50,50), time = c(0,2,3,10))
inf_pd <- apply_tci(pd_targets, pkmod = modpd, type = "effect")
```

We can then similarly use `predict.pkmod` and `simulate.pkmod` methods to predict and simulate PD responses. BIS measurements may be collected at a rate of one observation per 10-20 seconds, depending on the BIS device settings.

```{r}
# predict responses
pre_pd <- predict(modpd, inf = inf_pd, tms = tms_pred)
# pd observations: 10 sec = 1/6 min
tms_pd_obs <- seq(1/6,10,1/6) 
# simulate responses with additive error and parameter misspecification
obs_pd <- simulate(modpd, seed = 1, inf = inf_pd, tms = tms_pd_obs, sigma_add = 5, 
                   pars_pk = c(ke0 = 0.7), pars_pd = c(c50 = 3, gamma = 1.8))

# plot results
dat_pd <- data.frame(time = tms_pred, `plasma (3 cmpt)` = pre_pd[,"c1"], 
                  `effect (ke0=1.2)` = pre_pd[,"c4"],
                  BIS = pre_pd[,"pdresp"],
                  check.names = FALSE)
dat_pdm <- melt(dat_pd, id = "time")
dat_pdm$type <- as.factor(ifelse(dat_pdm$variable == "BIS", "PD","PK"))
dat_pd_obs <- data.frame(time = tms_pd_obs, BIS = obs_pd, 
                         type = factor("PD"), variable = "BIS")
levels(dat_pdm$type) <- levels(dat_pd_obs$type) <- c("Bispectral Index", "Concentration (mg/L)")

ggplot(dat_pdm, aes(x = time, y = value, color = variable)) + 
  facet_wrap(type~., scales = "free", nrow = 2) +
  geom_line() + 
  geom_point(data = dat_pd_obs, aes(x = time, y = BIS)) + 
  xlab("Minutes") + ylab("")
```


## Closed-loop control

Closed-loop control systems automatically adjust controlled variable(s), in this case the infusion rate, in response to patient feedback. In `tci`, closed-loop control is implemented through the function `simulate_clc`, which applies Bayesian updates to update a patient's prior PK or PK-PD model as data are simulated according to a second, "true" PK/PK-PD model. To use `simulate_clc`, the user must specify 

1. A *prior* `pkmod` object describing the prior patient model. This model must have an associated `Omega` matrix describing inter-individual variability in PK-PD parameters. Any parameters that aren't listed in the column names of `Omega` are assumed to be fixed and aren't updated by `simulate_clc`.
2. A *true* `pkmod` object describing the model from which data are generated. The true model does not need to have the same structure as the prior model.
3. A set of targets for the TCI algorithm.
4. Times at which to simulate observations from the "true" model.
5. Times at which to update the prior model with the observed values.


### PK example - plasma targeting

Below we illustrate use of this function in the following scenario. A medication is administered to a patient via IV infusion once every 24 hours for three days. Each infusion is administered over the course of an hour at a rate calculated to reach a target plasma concentration of 3 mg/L. 

```{r}
# TCI targets - 3 doses (hour-long infusions) at 24h intervals calculated to 
# reach 3 mg/L plasma concentration
targets <- cbind(time = c(0,1,24,25,48,49,72), value = c(3,0,3,0,3,0,0))
```

Samples are collected at 1, 2, 4, 8, 12, 16, 23, 25, 36, and 47 hours and are used to update the patient's model at 24 and 48 hours. 

```{r}
# Measurement and model update times
obs_tms <- c(1,2,4,8,12,16,23,25,36,47)
update_tms <- c(24,48)
```

The drug's PK are believed to be best-described by a one-compartment model, but in fact are described by a three-compartment model. 

```{r}
# Omega matrix describing inter-individual variability in prior pkmod object
prior_vcov <- matrix(diag(c(0.265,0.610,0.463)), 
                     3,3, dimnames = list(NULL,c('cl','v','sigma_mult')))
# prior pkmod: 1 compartment model
pkmod_prior <- update(mod1cpt, Omega = prior_vcov, sigma_mult = 0.2)

# true pkmod - 3 compartment model with effect-site
pkmod_true <- update(mod3ecpt, sigma_mult = 0.3)
```

We now run the simulation using a plasma-targeting TCI algorithm and plot the results.
```{r}
# run simulation
sim <- simulate_clc(pkmod_prior, pkmod_true, targets, obs_tms, update_tms, 
                    type = "plasma", seed = 1)
len <- 1000
tms <- seq(0,48,length.out = len)

# true, prior, posterior plasma concentrations
ctrue <- predict(pkmod_true, sim$inf,tms)[,1]
cprior <- predict(pkmod_prior, sim$inf,tms)[,1]
post_pars <- sim$pars[nrow(sim$pars),]
cpost  <- predict(pkmod_prior, sim$inf,tms, pars_pk = post_pars[1:7], 
                  sigma_add = post_pars[8])[,1]
df <- data.frame(time = rep(tms,3),
                value = c(ctrue, cprior, cpost),
                model = c(rep("true",len),rep("prior",len),rep("posterior",len)))
p1 <- ggplot(df, aes(x = time, y = value, color = model)) +
 geom_line() +
 geom_point(data = sim$obs, aes(x = time, y = obs), inherit.aes = FALSE) +
 labs(x = "Time (h)", y = "Concentration (mg/L)") +
 geom_vline(xintercept = update_tms, linetype = "dotted", alpha = 0.6)

p2 <- ggplot(as.data.frame(sim$inf), aes(x = begin, y = infrt)) + 
  geom_line() + 
  labs(x = "Time (h)", y = "Infusion rate (mg/h)")

plot(arrangeGrob(p1,p2, ncol = 2))
```

Due to the structural model misspecification, the posterior model substantially under-predicts the true concentrations and delivers infusions that results in maximum concentrations substantially higher than the intended 3 mg/L at 24 and 48 hours. 


## PK-PD example - effect-site targeting

We now consider applying closed-loop control to a patient's BIS signal during the induction of anesthesia with propofol. As in the prior PK-PD example, propofol PK are described by a three-compartment effect-site model and the BIS response by an Emax model. A target of BIS=50 will be used with observations simulated at a rate of one observation per 10 seconds and model parameters updated every minute. We will further assume that there is a delay in processing the BIS signal, such that measurements are not available until 30 seconds after they are collected. This is implemented in `simulate_clc` by setting the `delay` parameter. For the prior model, we will assume that the only parameters that vary within the population are the clearance parameters, the effect-site equilibrium constant, the concentration associated with 50\% effect, and the residual error. 

```{r}
pkpd_prior_vcov <- matrix(diag(c(0.265,0.346,0.209,0.702,0.242,0.230)),6,6, 
                          dimnames = list(NULL,c('cl','q2','q3','ke0','c50',
                                                 'sigma_add')))

pkpdmod_prior <- update(modpd, sigma_add = 6, Omega = pkpd_prior_vcov)
pkpdmod_true <- update(modpd, sigma_add = 7, 
                       pars_pk = c(cl = 20,q2=6,q3=50,ke0=0.8),
                       pars_pd = c(c50=2.5))

targets <- cbind(value = c(50,50), time = c(0,10))
obs_tms <- seq(1/6,10,1/6)
update_tms <- seq(1,10,0.5)

sim_pkpd <- simulate_clc(pkmod_prior = pkpdmod_prior, 
                         pkmod_true = pkpdmod_true, 
                         targets = targets, 
                         obs_tms = obs_tms, 
                         update_tms = update_tms, 
                         seed = 1, delay = 0.5)
```


```{r}
# plot results
tms <- seq(0,10,length.out = len)
resp_true <- predict(pkpdmod_true, sim_pkpd$inf,tms)[,5]
resp_prior <- predict(pkpdmod_prior, sim_pkpd$inf,tms)[,5]
post_pars <- sim_pkpd$pars[nrow(sim_pkpd$pars),]
resp_post  <- predict(pkpdmod_prior, sim_pkpd$inf, tms, 
                      pars_pk = post_pars[1:4], pars_pd = post_pars[5], 
                      sigma_add = post_pars[6])[,5]
df <- data.frame(time = rep(tms,3),
                 value = c(resp_true, resp_prior, resp_post),
                 model = c(rep("true",len),rep("prior",len),rep("posterior",len)))

ggplot(df, aes(x = time, y = value, color = model)) +
  geom_line() +
  geom_point(data = sim_pkpd$obs, aes(x = time, y = obs), inherit.aes = FALSE) +
  labs(x = "Hours", y = "Bispectral Index") +
  geom_vline(xintercept = update_tms, linetype = "dotted", alpha = 0.6) +
  geom_step(data = as.data.frame(targets), aes(x = time, y = value), inherit.aes = FALSE)
```





### References



