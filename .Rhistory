if(!("pars" %in% names(dot.args)) &
is.symbol(formals(object)$pars))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
# Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dtm.
if(!is.null(tms)){
# round times - this is needed to prevent errors associated with rounding numeric values
tms <- round(tms, tm_digits)
# if times are provided, predict at those times plus boundaries for initial values
bnd <- sort(unique(
round(as.numeric(unlist(inf[,c("begin","end")])),tm_digits)
))
tms_all <- sort(unique(
round(c(bnd,tms),tm_digits)
))
tms_eval <- split(tms_all, findInterval(tms_all, bnd,
rightmost.closed = TRUE,
left.open = TRUE))
} else{
# if times are not provided, predict across a grid of points
tms_eval <- mapply(seq, inf[,"begin"]+dtm, inf[,"end"], by = dtm,
SIMPLIFY = FALSE)
tms_all <- unlist(tms_eval)
}
init <- vector("list", nrow(inf)+1)
# Pass on initial concentrations to first element of init. Use values if specified, else defaults.
if("init" %in% names(dot.args)){
init[[1]] <- unlist(dot.args$init)
dot.args$init <- NULL
} else {
init[[1]] <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
# get indexes of times and initialize matrix for predictions
tm_ix <- lapply(tms_eval, function(x) match(x,tms_all))
ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
#' spanning the infusions at intervals of dtm.
#' @param dtm Interval used for prediction if argument tms is unspecified.
#' @param return_init Logical indicating if concentrations at time 0 should
#' be returned. Defaults to FALSE.
#' @param remove_bounds Logical, indicating if concentrations calculated at
#' changes in infusion rates should be returned if not included in prediction
#' times. Defaults to TRUE, so that only concentrations at specified times
#' are returned.
#'
#' @export
predict_pkmod_Rcpp <- function(object, ..., inf, tms = NULL, dtm = 1/6, return_init = FALSE,
remove_bounds = TRUE){
ncmpt <- NA
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.symbol(formals(object)$pars))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
if("init" %in% names(dot.args)){
init <- unlist(dot.args$init)
} else {
init <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
begin <- inf[,"begin"]
end <- inf[,"end"]
infs <- inf[,"infrt"]
ncmpt <- length(init)
if(is.null(tms)){
tms <- seq(min(begin)+dtm, max(end), by = dtm)
}
# evaluate times starting from the first infusion
tms_eval <- tms - min(begin)
# inf[i,"begin"]
pars_eval <- format_pars(pars, ncmpt = ncmpt)
if(ncmpt == 1){
pred <- t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
}
if(ncmpt == 2){
pred <- pksol2cpt(tms_eval, pars_eval, begin, end, infs, init)
}
if(ncmpt == 3){
pred <- pksol3cpt(tms_eval, pars_eval, begin, end, infs, init)
}
if(ncmpt == 4){
pred <- pksol3cptm(tms_eval, pars_eval, begin, end, infs, init)
}
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(tms, c(pred))
} else{
predtms <- cbind(tms, t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init)))
return(predtms)
}
undebug(gen_data)
set.seed(1)
bayes_sim <- bayes_control(targets = targets,
updates = update_times,
prior = prior_pars,
true_pars = true_pars)
plot(bayes_sim)
set.seed(1)
library(tci)
bayes_sim <- bayes_control(targets = targets,
updates = update_times,
prior = prior_pars,
true_pars = true_pars)
plot(bayes_sim) + ylab("Bispectral Index (BIS)") + xlab("Minutes")
inf
library(tci)
theta <- c(v1 = 8.995, v2 = 17.297, v3 = 120.963, cl = 1.382,
q2 = 0.919, q3 = 0.609, ke0 = 1.289, c50 = 2.8, gamma = 1.47,
gamma2 = 1.89, e0 = 93, emx = 93, sigma = 8.03, bis_delay = 28.263)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect
inf_effect[,"begin"]
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1
inf_effect[,"end"] <- inf_effect[,"end"] + 1
inf_effect
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
class(pkmod1cpt_test) <- "pkmod"
inf_effect
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod2(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
pkmod1cpt
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
library(tci)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
debug(predict_pkmod_Rcpp)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
pksol1cpt
library(tci)
packageVersion("tci")
library(tci)
theta <- c(v1 = 8.995, v2 = 17.297, v3 = 120.963, cl = 1.382,
q2 = 0.919, q3 = 0.609, ke0 = 1.289, c50 = 2.8, gamma = 1.47,
gamma2 = 1.89, e0 = 93, emx = 93, sigma = 8.03, bis_delay = 28.263)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1
inf_effect[,"end"] <- inf_effect[,"end"] + 1
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
pkmod1cpt
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
class(pkmod1cpt_test) <- "pkmod"
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1.2
inf_effect[,"end"] <- inf_effect[,"end"] + 1.2
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
inf_effect
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
inf_effect
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
inf_effect
# install.packages("../CRAN/tci_0.1.2.tar.gz", repos = NULL, type = "source")
library(Rcpp)
sourceCpp("src/pk_cpp_functions.cpp")
Rcpp::sourceCpp("src/pk_cpp_functions.cpp")
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
debug(predict_pkmod)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
undebug(predict_pkmod)
debug(predict_pkmod_Rcpp)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
vals <<- list(tms_eval, pars_eval, begin, end, infs, init)
vals[[1]]
vals[[2]]
pksol1cpt(vals[[1]],vals[[2]], vals[[3]], vals[[4]], vals[[5]], vals[[6]])
inf_effect
tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
undebug(predict_pkmod_Rcpp)
tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
Rcpp::sourceCpp("src/pk_cpp_functions.cpp")
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
Rcpp::sourceCpp("src/pk_cpp_functions.cpp")
library(tci)
theta <- c(v1 = 8.995, v2 = 17.297, v3 = 120.963, cl = 1.382,
q2 = 0.919, q3 = 0.609, ke0 = 1.289, c50 = 2.8, gamma = 1.47,
gamma2 = 1.89, e0 = 93, emx = 93, sigma = 8.03, bis_delay = 28.263)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1.2
inf_effect[,"end"] <- inf_effect[,"end"] + 1.2
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
class(pkmod1cpt_test) <- "pkmod"
Rcpp::sourceCpp("src/pk_cpp_functions.cpp")
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
debug(predict_pkmod_Rcpp)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
begin
end
pksol1cpt(tms_eval, pars_eval, begin, end, infs, init)
pksol1cpt
library(tci)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
library(tci)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0.2)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0.2)
library(tci)
# Chunk 1: knitr_setup
## install from github
# devtools::install_github("jarretrt/tci")
library(tci)
library(gridExtra)
library(xtable)
library(ggplot2)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
options(xtable.comment = FALSE)
# Chunk 2: patient-covariates
# Access Eleveld et al. (2018) data
data(eleveld_pk)
id <- 47 # example patient
patient_covariates <- eleveld_pk[eleveld_pk$ID == id,
c("ID","AGE","PMA","WGT","HGT","TECH","BMI","M1F2","A1V2")]
pkpd_vars <- c("V1","V2","V3","CL","Q2","Q3","KE0","CE50","BIS0","BIS0",
"GAMMA","GAMMA2","SIGMA","BIS_DELAY")
# prior point estimates - non-random
theta <- unlist(eleveld_poppk(patient_covariates)[,pkpd_vars])
# "true" parameter values via Monte Carlo sampling
set.seed(1)
theta0 <- unlist(eleveld_poppk(patient_covariates, rand = TRUE)[,pkpd_vars])
# Chunk 5: tci-base
theta <- c(v1 = 8.995, v2 = 17.297, v3 = 120.963, cl = 1.382,
q2 = 0.919, q3 = 0.609, ke0 = 1.289, c50 = 2.8, gamma = 1.47,
gamma2 = 1.89, e0 = 93, emx = 93, sigma = 8.03, bis_delay = 28.263)
kR_Cp <- tci_plasma(Cpt = 2, dtm = 1, pkmod = pkmod3cptm, pars = theta[1:7])
kR_Ce <- tci_effect(Cet = 2, dtm = 1, pkmod = pkmod3cptm, pars = theta[1:7])
print(round(c(kR_Cp = kR_Cp, kR_Ce = kR_Ce),2))
# Chunk 6: tci-illustration
inf_plasma <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,1,6,11), pkmod = pkmod3cptm,
pars = theta, tci_alg = "plasma")
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,1,6,11), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
# Chunk 7: tci-illustration2
head(inf_plasma,3)
head(inf_effect,3)
# Chunk 8: tci-illustration-plot
library(ggplot2)
library(gridExtra)
grid.arrange(
plot(inf_plasma, title = "Plasma targeting", display = FALSE) +
ylab("Concentration (ng/L)") + xlab("Time (min)"),
plot(inf_effect, title = "Effect-site targeting", display = FALSE) +
ylab("Concentration (ng/L)") + xlab("Time (min)")
)
# Chunk 9: calc-tci-bis
tci_bis <- tci_pd(pdresp = c(40,50,60,60), tms = c(0,5,10,15), pdinv = inv_emax,
pdmod = emax, pkmod = pkmod3cptm, pars_pk = theta[1:7],
pars_pd = theta[8:12])
# Chunk 10: plot-tci-bis
plot(tci_bis)
# Chunk 11: gen-data-example
theta0 <- c(v1 = 5.515, v2 = 19.857, v3 = 63.423, cl = 3.142, q2 = 1.237,
q3 = 0.258, ke0 = 2.088, c50 = 4.026, gamma = 1.47, gamma2 = 1.89,
e0 = 93, emx = 93, sigma = 6.936, bis_delay = 28.263)
pkpddsim <- gen_data(inf = tci_bis, pkmod = pkmod3cptm, pdmod = emax, pars_pk0 = theta0, pars_pd0 = theta0, sigma_add = theta0["sigma"], delay = theta0["bis_delay"])
head(round(pkpddsim$sim,3),3)
# Chunk 12: gen-data-plot
plot(pkpddsim) + ylab("Bispectral Index (BIS)") + xlab("Minutes")
# Chunk 13: bayes-control-1
targets <- data.frame(time = c(0,5,10,15), target = c(40,50,60,60))
update_times <- data.frame(time = seq(1,15,1),
full_data = rep(TRUE,15))
# Chunk 14: prior-pars
rand_vars <- c("V1","V2","V3","CL","Q2","Q3","KE0","CE50","SIGMA")
set.seed(1)
theta_samples <- replicate(1e3, unlist(eleveld_poppk(patient_covariates,
rand = TRUE)[,rand_vars]))
prior_pars <- list(pars_pkpd = theta[1:12], sig = cov(t(log(theta_samples))),
pk_ix = 1:7, pd_ix = 8:12, fixed_ix = 9:12,
err = theta["sigma"], delay = theta["bis_delay"]/60)
# Chunk 15: true-pars
true_pars <- list(pars_pkpd = theta0[1:12], pk_ix = 1:7, pd_ix = 8:12,
fixed_ix = 9:12, err = theta0["sigma"],
delay = theta0["bis_delay"]/60)
set.seed(1)
bayes_sim <- bayes_control(targets = targets,
updates = update_times,
prior = prior_pars,
true_pars = true_pars)
plot(bayes_sim) + ylab("Bispectral Index (BIS)") + xlab("Minutes")
bayes_sim <- bayes_control(targets = targets,
updates = update_times,
prior = prior_pars,
true_pars = true_pars)
plot(bayes_sim) + ylab("Bispectral Index (BIS)") + xlab("Minutes")
library(mrgsolve)
form <- '
$PARAM V1=1, V2=2, V3=3, CL1=1.1, CL2=1.2, CL3=1.3, k12=0.4, k21=0.6,
k13=0.6, k31=0.3, k10=0.8
$CMT A1 A2 A3
$ODE
dxdt_A1 = -CL1*A1/V1 + k21*A2 + k31*A3 - (k12+k13+k10)*A1;
dxdt_A2 = k12*A1-k21*A2 - CL2*A2/V2;
dxdt_A3 = k13*A1-k31*A3 - CL3*A3/V3;
'
mod_remif <- mcode("remifentanil", form)
pk_remif <- function(tm, kR, pars, init = c(0,0,0), inittm = 0){
# begin times at 0 and end at last time evaluated
tm <- tm - inittm
end_inf <- max(tm)
# pass parameters as list
pars <- sapply(pars, as.list)
vols <- unlist(pars[c("V1","V2","V3")])
A0 <- init*vols # initial amounts
names(A0) <- c("A1","A2","A3") # names required by mrgsolve
# update parameters and initial values (as amounts)
mod_remif <- update(mod_remif, param = pars, init = A0)
# dosing regimen - mrgsolve function in terms of amount infused
event <- ev(amt =  kR*end_inf, time = 0, tinf = end_inf)
# simulate responses (skip tm=0 unless specified)
dat <- mrgsim_q(x = mod_remif, # pk model
data = event, # dosing event
stime = tm) # evaluation times
# skip tm=0 unless specified in tm
dat <- dat@data[-1,]
# return concentrations with compartments in rows and times in columns
cons <- t(dat[,c("A1","A2","A3")]) / vols
rownames(cons) <- colnames(cons) <- NULL
return(cons)
}
class(pk_remif) <- "pkmod"
tab_cascone <- data.frame(Parameter1 = c("$V_1$","$V_2$","$V_3$","$CL_1$",
"$CL_2$","$CL_3$"),
Optimized_val1 = c("7.88 L","23.9 L","13.8 L",
"2.08 L/min","0.828 L/min","0.0784 L/min"),
Parameter2 = c("$k_{10}$","$k_{12}$","$k_{21}$","$k_{13}$","$k_{31}$",""),
Optimized_val2 = c("0.172/min","0.373/min","0.103/min","0.0367/min","0.0124/min",""))
names(tab_cascone) <- c("Parameter", "Optimized value", "Parameter", "Optimized value")
tab_cascone_df <- xtable(tab_cascone,
caption = "Reproduction of Table 1 from Cascone et al. (2013): Values and dimensions of the three-compartmental model parameters.",
label = "tab:Cascone-tab1")
print(tab_cascone_df,
include.rownames = FALSE,
caption.placement = "top",
timestamp = NULL,
booktabs = TRUE,
hline.after = c(-1,0,6),
sanitize.text.function = function(x){x},
include.colnames=TRUE)
pars_remif <- c(V1 = 7.88, V2=23.9, V3=13.8, CL1=2.08, CL2=0.828, CL3=0.0784,
k10=0.172, k12=0.373, k21=0.103, k13=0.0367, k31=0.0124)
dtm = 1
dose = 1
inf <- cbind(begin = c(0,20), end = c(20,200),
infrt = c(dose*60,0))
bolus <- cbind(begin = c(0,dtm), end = c(dtm,200),
infrt = c(dose*60/dtm,0))
pb <- plot(pk_remif, pars = pars_remif, inf = bolus, title = "Bolus") +
scale_y_log10() + ylab("Concentration (ng/mL)") + xlab("Minutes")
pi <- plot(pk_remif, pars = pars_remif, inf = inf, title = "Infusion") +
scale_y_log10() + ylab("Concentration (ng/mL)") + xlab("Minutes")
grid.arrange(pb,pi,nrow = 2)
pk_remif
tci_plasma_lim <- function(Cet, pkmod, pars, init = NULL, dtm = 1/6,
lim_amt = 0.5,ecmpt = NULL, tmax_search = 20,
cetol = 0.05, cptol = 0.1, maxrt = 1200){
if(is.null(init))
init <- eval(formals(pkmod)$init)
if(is.null(ecmpt))
ecmpt <- length(init)
ecmpt_name <- paste0("c", ecmpt)
# if effect-site concentration is close to target,
# switch to plasma targeting
if((Cet - init[ecmpt]) / Cet <  cetol &
(Cet - init[1])/Cet <= cptol)
return(tci_plasma(Cet, pkmod = pkmod, dtm = dtm, maxrt = maxrt,
init = init, pars = pars))
Cp_max <- Cet + lim_amt
# infusion required to reach Cp_max
pinf <- tci_plasma(Cpt = Cp_max, pkmod = pkmod, dtm = dtm, maxrt = maxrt,
init = init, pars = pars)
# Administer dtm-minute infusion
unit_inf <- create_intvl(
data.frame(time = c(dtm, tmax_search),
infrt = c(pinf, 0))
)
# Calculate maximum effect-site concentration
CeP <- function(tm) predict_pkmod(pkmod, inf = unit_inf, pars = pars,
init = init, tms = tm)[,ecmpt_name]
Ce_max <- optimize(CeP, c(0,20), maximum = TRUE)$objective
# if max Ce < Cet administer infusion to reach maximum target
if(Ce_max <= Cet + cetol*Cet)
infrt <- pinf
else
infrt <- tci_effect(Cet, pkmod, dtm, ecmpt, init = init, pars = pars)
return(infrt)
}
tci_effect
tci_plasma_lim(Cet = 2, pkmod = pkmod3cptm, pars = theta, lim_amt = 0.25)
tci_custom_alg <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,1,6,11),
pkmod = pkmod3cptm, pars = theta,
tci_custom = tci_plasma_lim, lim_amt = 0.25)
plot(tci_custom_alg, title = "Plasma-limiting effect-site TCI algorithm")
library(tci)
library(devtools)
document()
