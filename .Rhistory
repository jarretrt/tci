# true patient parameters
pars_3cpt0 <- c(k10=1.7,k12=0.13,k21=0.1,k13=0.8,k31=0.8,
v1=15,v2=16,v3=90,ke0=1.2)
pars_emax0 <- c(c50 = 1.2, gamma = 3.5, e0 = 100, emx = 100)
# Predicted concentrations / responses under model with pars
# "pars_3cpt", "pars_emax"
tci_bis_res <- tci_pd(pdresp = c(40,50,70,70),
tms = c(0,5,10,15),
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
# Generate data using infusion schedule above under a different PK-PD model
# additive, normally distributed errors
pkpddsim <- gen_data(inf = tci_bis_res,
pkmod = pkmod3cptm,
pdmod = emax,
pars_pk0 = pars_3cpt0,
pars_pd0 = pars_emax0,
sigma_add = 7)
pkpddsim
plot(pkpddsim)
head(round(pkpddsim$sim,3))
plot(pkpddsim)
plot_datasim
plot.datasim
plot_datasim(pkpddsim)
library(tci)
# Chunk 1
# install most recent version from github
# devtools::install_github("jarretrt/tci")
# load packages
library(tci)
library(knitr)
library(gridExtra)
opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.align="center")
# Chunk 2
knitr::include_graphics("figures/one_compartment_diagram.pdf")
# Chunk 3
knitr::include_graphics("figures/three_compartment_diagram.pdf")
# Chunk 4
# e.g. infusion rates of 100 ug/min for 30 sec intervals at 0,4 minutes
dose <- create_intvl(
as.matrix(cbind(time = c(0.5,4,4.5,10),
infrt = c(100,0,100,0))),
inittm = 0
)
dose
# Chunk 5
# predict one compartment model at regular interals
pars_1cpt <- c(ke = 0.1, v = 10)
head(
predict(pkmod1cpt,
inf = dose,
pars = pars_1cpt,
init = 0,
dtm = 1/2),
3)
# Chunk 6
# predict for 3cpt model
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,
k31=0.8,v1=10,v2=15,v3=100,ke0=1)
pkmod3cptm <- assign_pars(pkmod3cptm, pars_3cpt)
predict(pkmod3cptm,
inf = dose,
tms = c(1,2,8))
# Chunk 7
p1cmpt <- plot(pkmod1cpt,
inf = dose,
pars = pars_1cpt,
title = "Plasma concentrations for a 1 compartment model")
p3cmpt <- plot(pkmod3cptm, inf = dose,
title = "Concentrations for a 3 compartment \n model with an effect site")
grid.arrange(p1cmpt, p3cmpt)
# Chunk 8
library(mrgsolve)
# define two-compartment model from ODEs
code <- '
$PARAM CL=10, V=10, Q = 10, V2=10
$CMT A1 A2
$ODE
dxdt_A1 = -(CL/V)*A1 - (Q/V)*A1 + (Q/V2)*A2;
dxdt_A2 = -(Q/V2)*A2 + (Q/V)*A1;
'
mod2cpt <- mcode("example", code)
# wrapper function to evaluate mod2cpt in format used by tci
pkmod2cpt_ode <- function(tm, kR, pars,
pkm = pk2,
init = c(0,0),
inittm = 0){
# begin times at 0 and end at last time evaluated
tm <- tm - inittm
end_inf <- max(tm)
# name parameter/initial concentrations
names(pars) <- toupper(names(pars))
names(init) <- c("A1","A2")
# pass parameters as list
pars <- sapply(pars, as.list)
vols <- unlist(pars[c("V","V2")])
# update parameters and initial values (as amounts)
mod2cpt <- update(mod2cpt, param = pars, init = init*vols)
# dosing regimen - mrgsolve function in terms of amount infused
event <- ev(amt =  kR*end_inf, time = 0, tinf = end_inf)
# simulate responses (skip tm=0 unless specified)
dat <- mrgsim_q(x = mod2cpt, # pk model
data = event, # dosing event
stime = tm)@data[-1,] # evaluation times
# return concentrations with compartments in rows and times in columns
cons <- t(dat[,c("A1","A2")]) / vols
rownames(cons) <- colnames(cons) <- NULL
return(cons)
}
class(pkmod2cpt_ode) <- "pkmod"
# plot infusions
plot(pkmod2cpt_ode,
pars = c(CL=15, V=10, Q=10, V2=20),
inf = dose,
title = "Concentrations for a user-defined
2-compartment model")
# Chunk 9
# One compartment model
# find infusion to increase plasma concentration to 2 within 2 minutes.
(inf_est_1cmpt <- tci_plasma(Cpt = 2, dtm = 2, pkmod = pkmod1cpt, pars = pars_1cpt))
inf_2min_1cpt <- create_intvl(data.frame(time = c(2, 30),
infrt = c(inf_est_1cmpt,0)))
# three compartment model
inf_est_3cmpt <- tci_plasma(Cpt = 2, dtm = 2,
pkmod = pkmod3cptm,
pars = pars_3cpt,
init = c(1,0,0,0))
inf_2min_3cpt <- create_intvl(data.frame(time = c(2, 20),
infrt = c(inf_est_3cmpt,0)))
ptci_1cmpt <- plot(pkmod1cpt,
pars = pars_1cpt,
inf =  inf_2min_1cpt,
title = "10-Second infusion required to reach a
plasma concentration of 2")
ptci_3cmpt <- plot(pkmod3cptm,
pars = pars_3cpt,
inf =  inf_2min_3cpt,
init = c(1,0,0,0),
title = "Infusion required to reach a plasma concentration
of 2 in a 3-compartment model")
grid.arrange(ptci_1cmpt, ptci_3cmpt)
# Chunk 10
# Calculate the 10 second infusion rate required to reach a concentration
# of 2 ug/ml in the effect-site compartment with existing drug in the first
# compartment.
kR_2ug <- tci_effect(Cet = 2,
pkmod = pkmod3cptm,
pars = pars_3cpt,
init = c(1,0,0,0),
dtm = 1/6)
inf_2ug <- create_intvl(data.frame(time = c(1/6, 20),
infrt = c(kR_2ug,0)))
ptci_2ug <- plot(pkmod3cptm,
inf = inf_2ug,
pars = pars_3cpt,
init = c(1,0,0,0),
title = "10-sec infusion to reach a Cet of 2 in a 3cmpt
model with initial concentration")
# maintain and increase target concentrations
tms <- c(0,5,10)
Cet <- c(2,3,3)
# plasma-targeting
inf_3cpt_plasma <- tci(Ct = Cet,
tms = tms,
pkmod = pkmod3cptm,
pars = pars_3cpt,
tci_alg = "plasma")
# infusions for effect-site targeting
inf_3cpt_effect <- tci(Ct = Cet,
tms = tms,
pkmod = pkmod3cptm,
pars = pars_3cpt,
tci_alg = "effect",
cptol = 0.2)
ptci_2ug_plasma <- plot(inf_3cpt_plasma,
title = "Plasma targeting for three-compartment model",
display = FALSE)
ptci_2ug_effect <- plot(inf_3cpt_effect,
title = "Effect-site targeting for three-compartment model",
display = FALSE)
grid.arrange(ptci_2ug, ptci_2ug_plasma, ptci_2ug_effect)
# Chunk 11
tci_plasma_lim <- function(Cet, pkmod, pars, init = NULL, dtm = 1/6,
lim_amt = 0.5,ecmpt = NULL, tmax_search = 20,
cetol = 0.05, cptol = 0.1, maxrt = 1200){
if(is.null(init))
init <- eval(formals(pkmod)$init)
if(is.null(ecmpt))
ecmpt <- length(init)
ecmpt_name <- paste0("c", ecmpt)
# if effect-site concentration is close to target,
# switch to plasma targeting
if((Cet - init[ecmpt]) / Cet <  cetol &
(Cet - init[1])/Cet <= cptol)
return(tci_plasma(Cet, pkmod = pkmod, dtm = dtm, maxrt = maxrt,
init = init, pars = pars))
Cp_max <- Cet + lim_amt
# infusion required to reach Cp_max
pinf <- tci_plasma(Cpt = Cp_max, pkmod = pkmod, dtm = dtm, maxrt = maxrt,
init = init, pars = pars)
# Administer dtm-minute infusion
unit_inf <- create_intvl(
data.frame(time = c(dtm, tmax_search),
infrt = c(pinf, 0))
)
# Calculate maximum effect-site concentration
CeP <- function(tm) predict(pkmod, inf = unit_inf, pars = pars,
init = init, tms = tm)[,ecmpt_name]
Ce_max <- optimize(CeP, c(0,20), maximum = TRUE)$objective
# if max Ce < Cet administer infusion to reach maximum target
if(Ce_max <= Cet + cetol*Cet)
infrt <- pinf
else
infrt <- tci_effect(Cet, pkmod, dtm, ecmpt, init = init, pars = pars)
return(c(kR = infrt))
}
# Chunk 12
tci_plasma_lim(Cet = 2, pkmod = pkmod3cptm, pars = pars_3cpt,
lim_amt = 0.25)
inf_3cpt_custom <- tci(Ct = Cet,
tms = tms,
pkmod = pkmod3cptm,
pars = pars_3cpt,
tci_custom = tci_plasma_lim,
lim_amt = 0.25)
plot(inf_3cpt_custom,
title = "Custom TCI algorithm for three-compartment model")
# Chunk 13
pars_emax <- c(c50 = 1.5, gamma = 4, e0 = 100, emx = 100)
tci_bis_res <- tci_pd(pdresp = c(40,50,60,60),
tms = c(0,5,10,15),
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
# plot TCI object with pd response
plot(tci_bis_res, title = "Extension of TCI algorithm to PD targets")
# Chunk 14
# true patient parameters
pars_3cpt0 <- c(k10=1.7,k12=0.13,k21=0.1,k13=0.8,k31=0.8,
v1=15,v2=16,v3=90,ke0=1.2)
pars_emax0 <- c(c50 = 1.2, gamma = 3.5, e0 = 100, emx = 100)
# Predicted concentrations / responses under model with pars
# "pars_3cpt", "pars_emax"
tci_bis_res <- tci_pd(pdresp = c(40,50,70,70),
tms = c(0,5,10,15),
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
# Generate data using infusion schedule above under a different PK-PD model
# additive, normally distributed errors
pkpddsim <- gen_data(inf = tci_bis_res,
pkmod = pkmod3cptm,
pdmod = emax,
pars_pk0 = pars_3cpt0,
pars_pd0 = pars_emax0,
sigma_add = 7)
head(round(pkpddsim$sim,3))
plot(pkpddsim)
library(tci)
plot.datasim
plot(pkpddsim)
bayes_sim$prior
bayes_sim
# Chunk 1
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
echo = TRUE,
message = FALSE,
warning = FALSE,
fig.align="center",
fig.height= 6,
fig.width = 6
)
# Chunk 2
library(tci)
data("eleveld_pk")
data("eleveld_pd")
# 122 patients had both pk and pd measurements
pkpd_eb <- merge(eleveld_pk, eleveld_pd)
# Chunk 3
# Evaluate Eleveld model at covariate values for patient 1
prior_pars_id1 <- eleveld_poppk(df = pkpd_eb[1,])
prior_pars_id1
# tci infusions are calculated using prior parameter estimates
pars_pk_id1 <- unlist(prior_pars_id1[,c("V1","V2","V3","CL","Q2","Q3","KE0")])
# BIS0 is repeated since BIS at maximum effect = BIS0 for Eleveld model
pars_pd_id1 <- unlist(prior_pars_id1[,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
# Chunk 4
olc_inf_id1 <- tci_pd(pdresp = c(50,50), # target BIS = 50
tms = c(0,5), # target for 5 minutes
pkmod = pkmod3cptm, # pk model
pdmod = emax_eleveld, # pd model
pdinv = inv_emax_eleveld, # inverse pd model
pars_pk = pars_pk_id1,
pars_pd = pars_pd_id1)
plot(olc_inf_id1)
# Chunk 5
# true set of patient parameters given by EB estimates
eb_pars_pk_id1 <- unlist(pkpd_eb[1,c("CL","Q2","Q3","V1","V2","V3","KE0")])
eb_pars_pd_id1 <- unlist(pkpd_eb[1,c("E50","GAM","GAM1","EMAX","EMAX")])
# residual error term
eb_sigma_id1 <- unlist(pkpd_eb[1,"RESD"])
# BIS delay - convert from minutes to seconds
eb_bd_id1 <- unlist(pkpd_eb[1,"ALAG1"]) * 60
# simulate response to infusions
set.seed(1)
datasim_id1 <- gen_data(inf = olc_inf_id1,
pkmod = pkmod3cptm,
pdmod = emax_eleveld,
pars_pk0 = eb_pars_pk_id1,
pars_pd0 = eb_pars_pd_id1,
sigma_add = eb_sigma_id1,
delay = eb_bd_id1)
# plot results
plot(datasim_id1)
cl_targets <- function(time, target){
data.frame(time = time, target = target)
}
cl_updates <- function(time, full_data = TRUE, plot_progress = FALSE){
data.frame(time = time, full_data = full_data, plot_progress = plot_progress)
}
# 1) Data frame of targets
targets = cl_targets(time = seq(0,10,1/6),
target = 50)
# 2) Update times
updates <- cl_updates(time = seq(2,10,2))
# 3) prior parameter values based on point estimates at covariate values
prior_par_list <- list(
pars_pkpd = prior_pars_id1[c("CL","Q2","Q3","V1","V2","V3",
"KE0","CE50","GAMMA","GAMMA2",
"BIS0","BIS0")],
pk_ix = 1:7, # indices of PK parameters
pd_ix = 8:12,
fixed_ix = 9:12, # indices of parameters that aren't updated
err = prior_pars_id1[1,"SIGMA"], # residual error
sig = eleveld_vcov(prior_pars_id1,
rates = FALSE)[[1]]
)
# 4) true parameter values based on EB values
true_par_list <- list(pars_pkpd = pkpd_eb[1,c("CL","Q2","Q3","V1",
"V2","V3","KE0",
"E50","GAM","GAM1",
"EMAX","EMAX")],
pk_ix = 1:7,
pd_ix = 8:12,
fixed_ix = 9:12,
err = pkpd_eb[1,"RESD"],
delay = pkpd_eb[1,"ALAG1"])
# run simulation
set.seed(1)
bayes_sim <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list,
true_pars = true_par_list)
#' @param init_p Predicted initial concentrations
#' @param obs_tms Times at which observations are collected. If null, observations will be
#' made at fixed intervals specified by 'dtm'.
#' @param dt_obs Interval between measurements.
#' @param sim_starttm Start time of simulation
#' @param tci_alg TCI algorithm used. Defaults to effect-site targeting.
#' @param print_progress Logical. Should current update times be printed to the console.
#'
#' @importFrom utils head tail
#' @export
bayes_control <- function(targets, updates, prior, true_pars,
pkmod = pkmod3cptm, pdmod = emax_eleveld,
pdinv = inv_emax_eleveld,
init0 = NULL, init_p = NULL, obs_tms = NULL,
dt_obs = 1/6, sim_starttm = 0, tci_alg = "effect",
print_progress = FALSE){
# set observation/measurement times
if(is.null(obs_tms)) obs_tms <- seq(dt_obs, max(targets$time), dt_obs)
# set true and predicted initial concentrations if not specified
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init0)) init0 <- rep(0,ncpt)
if(is.null(init_p)) init_p <- rep(0,ncpt)
init_start <- init0
if(is.vector(updates)) updates <- data.frame(time = updates)
if(!("time" %in% names(updates))) stop("dataframe updates must have column named 'time'")
if(!("full_data" %in% names(updates))) updates$full_data <- FALSE
if(!("plot_progress" %in% names(updates))) updates$plot_progress <- FALSE
# add simulation start time to list of update times
update_tms <- c(sim_starttm, updates$time)
update_full <- c(NA, updates$full_data)
plot_progress <- c(NA, updates$plot_progress)
true_pk <- unlist(true_pars$pars_pkpd[true_pars$pk_ix])
true_pd <- unlist(true_pars$pars_pkpd[-true_pars$pk_ix])
prior$pars_pkpd <- unlist(prior$pars_pkpd)
prior0 <- prior
dat0 <- NULL
lpr_all <- NULL
for(i in 2:length(update_tms)){
if(print_progress) print(paste("Updating at time t =", update_tms[i]))
prior_pk <- prior$pars_pkpd[prior$pk_ix]
prior_pd <- prior$pars_pkpd[prior$pd_ix]
# subset targets and observation times to period being updated
targets_sub <- targets[targets$time <= update_tms[i] & targets$time >= update_tms[i-1],]
obs_tms_sub <- obs_tms[obs_tms <= update_tms[i] & obs_tms > update_tms[i-1]]
# calculate tci infusions at prior parameter estimates for update period
inf <- tci_pd(pdresp  = targets_sub$target,
tms     = targets_sub$time,
pdinv   = pdinv,
pdmod   = pdmod,
pkmod   = pkmod,
pars_pk = prior_pk,
pars_pd = prior_pd,
init = init_p,
tci_alg = tci_alg)
# generate data under true model
dat <- gen_data(inf = inf,
tms = obs_tms_sub,
pkmod = pkmod,
pdmod = pdmod,
pars_pk0 = true_pk, # true pk parameters
pars_pd0 = true_pd, # true pd parameters
sigma_add = true_pars$err, # random error
delay = true_pars$delay, # bis delay in minutes
max_pdval = 100,
init = init0)
# merge sampled dataset with prior observations
dat0 <- combine_sim(dat0,dat)
# update parameters based on generated data
# use prior parameter values as starting point - separate fixed parameters
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
# indicate if full dataset should be used for updates
if(update_full[i]){
dat_eval <- dat0
# use full dataset and original vcov matrix
post_est <- optim(par = lpr,
fn = log_posterior_neg,
dat = dat_eval,
mu = lpr,
sig = prior0$sig,
pk_ix = prior$pk_ix,
pd_ix = prior$pd_ix,
fixed_ix = prior$fixed_ix,
fixed_lpr = lpr_fixed,
method = "BFGS",
hessian = FALSE)
} else{
dat_eval <- dat
post_est <- optim(par = lpr,
fn = log_posterior_neg,
dat = dat_eval,
mu = lpr,
sig = prior$sig,
fixed_lpr = lpr_fixed,
method = "BFGS",
hessian = TRUE)
# update vcov matrix
prior$sig <- solve(post_est$hessian)
}
if(plot_progress[i]){
print(plot(dat0, lpars_update = post_est$par,
lpars_fixed = log(prior$pars_pkpd[prior$fixed_ix])))
}
# update prior values
if(any(!is.null(prior$fixed_ix))){
prior$pars_pkpd[-prior$fixed_ix] <- exp(head(post_est$par,-1))
prior$err <- exp(tail(post_est$par,1))
} else{
prior$pars_pkpd <- exp(head(post_est$par,-1))
prior$err <- exp(tail(post_est$par,1))
}
# update true and predicted initial values
init0 <- dat0$sim[nrow(dat0$sim),grep("c[0-9]",colnames(dat0$sim))]
init_p <- as.numeric(predict(pkmod,
inf = dat0$inf,
tms = update_tms[i],
pars = prior$pars_pkpd[prior$pk_ix],
init = init_start)[-1])
}
# save final posterior parameter values
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
out <- list(dat = dat0,
lpr = lpr_all,
posterior = prior,
prior = prior0,
true_pars = true_pars)
class(out) <- "bayessim"
return(out)
}
bayes_sim <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list,
true_pars = true_par_list)
library(tci)
warnings()
plot(bayes_sim)
