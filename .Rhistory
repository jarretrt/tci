ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
con02 <- predict_pkmod2(object = pkmod, inf = inf, tms = tms, pars = pars_pk0, init = init)
con0
con02
tms
predict_pkmod(object = pkmod, inf = inf, tms = tms-1, pars = pars_pk0, init = init)
tms
#' spanning the infusions at intervals of dtm.
#' @param dtm Interval used for prediction if argument tms is unspecified.
#' @param return_init Logical indicating if concentrations at time 0 should
#' be returned. Defaults to FALSE.
#' @param remove_bounds Logical, indicating if concentrations calculated at
#' changes in infusion rates should be returned if not included in prediction
#' times. Defaults to TRUE, so that only concentrations at specified times
#' are returned.
#'
#' @export
predict_pkmod_Rcpp <- function(object, ..., inf, tms = NULL, dtm = 1/6, return_init = FALSE,
remove_bounds = TRUE){
ncmpt <- NA
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.symbol(formals(object)$pars))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
if("init" %in% names(dot.args)){
init <- unlist(dot.args$init)
} else {
init <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
begin <- inf[,"begin"]
end <- inf[,"end"]
infs <- inf[,"infrt"]
ncmpt <- length(init)
if(is.null(tms)){
tms <- seq(min(begin)+dtm, max(end), by = dtm)
}
# evaluate times starting from the first infusion
tms_eval <- tms - min(begin)
# inf[i,"begin"]
pars_eval <- format_pars(pars, ncmpt = ncmpt)
if(ncmpt == 1){
pred <- t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
}
if(ncmpt == 2){
pred <- pksol2cpt(tms_eval, pars_eval, begin, end, infs, init)
}
if(ncmpt == 3){
pred <- pksol3cpt(tms_eval, pars_eval, begin, end, infs, init)
}
if(ncmpt == 4){
pred <- pksol3cptm(tms_eval, pars_eval, begin, end, infs, init)
}
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(tms, c(pred))
} else{
predtms <- cbind(tms, t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init)))
return(predtms)
}
#' spanning the infusions at intervals of dtm.
#' @param dtm Interval used for prediction if argument tms is unspecified.
#' @param return_init Logical indicating if concentrations at time 0 should
#' be returned. Defaults to FALSE.
#' @param remove_bounds Logical, indicating if concentrations calculated at
#' changes in infusion rates should be returned if not included in prediction
#' times. Defaults to TRUE, so that only concentrations at specified times
#' are returned.
#'
#' @export
predict_pkmod <- function(object, ..., inf, tms = NULL, dtm = 1/6, return_init = FALSE,
remove_bounds = TRUE){
if(class(object) != "pkmod") stop("Object must have class 'pkmod'")
## apply Rcpp implementation to selected PK models
if(any(identical(object, pkmod1cpt),
identical(object, pkmod2cpt),
identical(object, pkmod3cpt),
identical(object, pkmod3cptm))){
return(predict_pkmod_Rcpp(object = object, ... = ..., inf = inf, tms = tms,
dtm = dtm, return_init = return_init,
remove_bounds = remove_bounds))
}
fptol = 1e-10
tm_digits = 7
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.symbol(formals(object)$pars))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
# Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dtm.
if(!is.null(tms)){
# round times - this is needed to prevent errors associated with rounding numeric values
tms <- round(tms, tm_digits)
# if times are provided, predict at those times plus boundaries for initial values
bnd <- sort(unique(
round(as.numeric(unlist(inf[,c("begin","end")])),tm_digits)
))
tms_all <- sort(unique(
round(c(bnd,tms),tm_digits)
))
tms_eval <- split(tms_all, findInterval(tms_all, bnd,
rightmost.closed = TRUE,
left.open = TRUE))
} else{
# if times are not provided, predict across a grid of points
tms_eval <- mapply(seq, inf[,"begin"]+dtm, inf[,"end"], by = dtm,
SIMPLIFY = FALSE)
tms_all <- unlist(tms_eval)
}
init <- vector("list", nrow(inf)+1)
# Pass on initial concentrations to first element of init. Use values if specified, else defaults.
if("init" %in% names(dot.args)){
init[[1]] <- unlist(dot.args$init)
dot.args$init <- NULL
} else {
init[[1]] <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
# get indexes of times and initialize matrix for predictions
tm_ix <- lapply(tms_eval, function(x) match(x,tms_all))
ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
predict_pkmod(object = pkmod, inf = inf, tms = tms, pars = pars_pk0, init = init)
predict_pkmod2(object = pkmod, inf = inf, tms = tms, pars = pars_pk0, init = init)
#' spanning the infusions at intervals of dtm.
#' @param dtm Interval used for prediction if argument tms is unspecified.
#' @param return_init Logical indicating if concentrations at time 0 should
#' be returned. Defaults to FALSE.
#' @param remove_bounds Logical, indicating if concentrations calculated at
#' changes in infusion rates should be returned if not included in prediction
#' times. Defaults to TRUE, so that only concentrations at specified times
#' are returned.
#'
#' @export
predict_pkmod <- function(object, ..., inf, tms = NULL, dtm = 1/6, return_init = FALSE,
remove_bounds = TRUE){
if(class(object) != "pkmod") stop("Object must have class 'pkmod'")
## apply Rcpp implementation to selected PK models
if(any(identical(object, pkmod1cpt),
identical(object, pkmod2cpt),
identical(object, pkmod3cpt),
identical(object, pkmod3cptm))){
return(predict_pkmod_Rcpp(object = object, ... = ..., inf = inf, tms = tms,
dtm = dtm, return_init = return_init,
remove_bounds = remove_bounds))
}
fptol = 1e-10
tm_digits = 7
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.symbol(formals(object)$pars))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
# Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dtm.
if(!is.null(tms)){
# round times - this is needed to prevent errors associated with rounding numeric values
tms <- round(tms, tm_digits)
# if times are provided, predict at those times plus boundaries for initial values
bnd <- sort(unique(
round(as.numeric(unlist(inf[,c("begin","end")])),tm_digits)
))
tms_all <- sort(unique(
round(c(bnd,tms),tm_digits)
))
tms_eval <- split(tms_all, findInterval(tms_all, bnd,
rightmost.closed = TRUE,
left.open = TRUE))
} else{
# if times are not provided, predict across a grid of points
tms_eval <- mapply(seq, inf[,"begin"]+dtm, inf[,"end"], by = dtm,
SIMPLIFY = FALSE)
tms_all <- unlist(tms_eval)
}
init <- vector("list", nrow(inf)+1)
# Pass on initial concentrations to first element of init. Use values if specified, else defaults.
if("init" %in% names(dot.args)){
init[[1]] <- unlist(dot.args$init)
dot.args$init <- NULL
} else {
init[[1]] <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
# get indexes of times and initialize matrix for predictions
tm_ix <- lapply(tms_eval, function(x) match(x,tms_all))
ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
#' spanning the infusions at intervals of dtm.
#' @param dtm Interval used for prediction if argument tms is unspecified.
#' @param return_init Logical indicating if concentrations at time 0 should
#' be returned. Defaults to FALSE.
#' @param remove_bounds Logical, indicating if concentrations calculated at
#' changes in infusion rates should be returned if not included in prediction
#' times. Defaults to TRUE, so that only concentrations at specified times
#' are returned.
#'
#' @export
predict_pkmod_Rcpp <- function(object, ..., inf, tms = NULL, dtm = 1/6, return_init = FALSE,
remove_bounds = TRUE){
ncmpt <- NA
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.symbol(formals(object)$pars))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
if("init" %in% names(dot.args)){
init <- unlist(dot.args$init)
} else {
init <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
begin <- inf[,"begin"]
end <- inf[,"end"]
infs <- inf[,"infrt"]
ncmpt <- length(init)
if(is.null(tms)){
tms <- seq(min(begin)+dtm, max(end), by = dtm)
}
# evaluate times starting from the first infusion
tms_eval <- tms - min(begin)
# inf[i,"begin"]
pars_eval <- format_pars(pars, ncmpt = ncmpt)
if(ncmpt == 1){
pred <- t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
}
if(ncmpt == 2){
pred <- pksol2cpt(tms_eval, pars_eval, begin, end, infs, init)
}
if(ncmpt == 3){
pred <- pksol3cpt(tms_eval, pars_eval, begin, end, infs, init)
}
if(ncmpt == 4){
pred <- pksol3cptm(tms_eval, pars_eval, begin, end, infs, init)
}
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(tms, c(pred))
} else{
predtms <- cbind(tms, t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init)))
return(predtms)
}
undebug(gen_data)
set.seed(1)
bayes_sim <- bayes_control(targets = targets,
updates = update_times,
prior = prior_pars,
true_pars = true_pars)
plot(bayes_sim)
set.seed(1)
library(tci)
bayes_sim <- bayes_control(targets = targets,
updates = update_times,
prior = prior_pars,
true_pars = true_pars)
plot(bayes_sim) + ylab("Bispectral Index (BIS)") + xlab("Minutes")
inf
library(tci)
theta <- c(v1 = 8.995, v2 = 17.297, v3 = 120.963, cl = 1.382,
q2 = 0.919, q3 = 0.609, ke0 = 1.289, c50 = 2.8, gamma = 1.47,
gamma2 = 1.89, e0 = 93, emx = 93, sigma = 8.03, bis_delay = 28.263)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect
inf_effect[,"begin"]
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1
inf_effect[,"end"] <- inf_effect[,"end"] + 1
inf_effect
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
class(pkmod1cpt_test) <- "pkmod"
inf_effect
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod2(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
pkmod1cpt
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
library(tci)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
debug(predict_pkmod_Rcpp)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
pksol1cpt
library(tci)
packageVersion("tci")
library(tci)
theta <- c(v1 = 8.995, v2 = 17.297, v3 = 120.963, cl = 1.382,
q2 = 0.919, q3 = 0.609, ke0 = 1.289, c50 = 2.8, gamma = 1.47,
gamma2 = 1.89, e0 = 93, emx = 93, sigma = 8.03, bis_delay = 28.263)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1
inf_effect[,"end"] <- inf_effect[,"end"] + 1
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
pkmod1cpt
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
pkmod1cpt_test <- function(tm, kR, pars, init = 0, inittm = 0){
tm <- tm - inittm
names(pars) <- tolower(names(pars))
if(any(!(c("k10","v1") %in% names(pars))) & any(!(c("cl","v1") %in% names(pars))))
stop("pars must have names ('k10','v1') or ('cl','v1')")
v1 <- pars["v1"]
if(!("k10" %in% names(pars)))
k10 <- pars["cl"] / v1
else
k10 <- pars["k10"]
return((kR/k10*(1-exp(-tm*k10)) + init*v1 * exp(-tm*k10)) / v1)
}
class(pkmod1cpt_test) <- "pkmod"
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
inf_effect <- tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
inf_effect[,"begin"] <- inf_effect[,"begin"] + 1.2
inf_effect[,"end"] <- inf_effect[,"end"] + 1.2
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2:5), init = 0)
inf_effect
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod_Rcpp(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
inf_effect
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
inf_effect
# install.packages("../CRAN/tci_0.1.2.tar.gz", repos = NULL, type = "source")
library(Rcpp)
sourceCpp("src/pk_cpp_functions.cpp")
Rcpp::sourceCpp("src/pk_cpp_functions.cpp")
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
debug(predict_pkmod)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
undebug(predict_pkmod)
debug(predict_pkmod_Rcpp)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
t.default(pksol1cpt(tms_eval, pars_eval, begin, end, infs, init))
vals <<- list(tms_eval, pars_eval, begin, end, infs, init)
vals[[1]]
vals[[2]]
pksol1cpt(vals[[1]],vals[[2]], vals[[3]], vals[[4]], vals[[5]], vals[[6]])
inf_effect
tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
undebug(predict_pkmod_Rcpp)
tci(Ct = c(1,2,2.5,2.5), tms = c(0,2,6,12), pkmod = pkmod3cptm,
pars = theta, tci_alg = "effect")
Rcpp::sourceCpp("src/pk_cpp_functions.cpp")
predict_pkmod(pkmod1cpt_test, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
predict_pkmod(pkmod1cpt, inf = inf_effect, pars = theta, tms = c(2,4,10,12), init = 0)
