bayes_control <- function(targets, updates, prior, true_pars,
pkmod = pkmod3cptm, pdmod = emax_eleveld,
pdinv = inv_emax_eleveld,
init0 = NULL, init_p = NULL, obs_tms = NULL,
dt_obs = 1/6, sim_starttm = 0, tci_alg = "effect",
print_progress = FALSE){
# set observation/measurement times
if(is.null(obs_tms)) obs_tms <- seq(dt_obs, max(targets$time), dt_obs)
# set true and predicted initial concentrations if not specified
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init0)) init0 <- rep(0,ncpt)
if(is.null(init_p)) init_p <- rep(0,ncpt)
init_start <- init0
if(is.vector(updates)) updates <- data.frame(time = updates)
if(!("time" %in% names(updates))) stop("dataframe updates must have column named 'time'")
if(!("full_data" %in% names(updates))) updates$full_data <- FALSE
if(!("plot_progress" %in% names(updates))) updates$plot_progress <- FALSE
# add simulation start time to list of update times
update_tms <- c(sim_starttm, updates$time)
update_full <- c(NA, updates$full_data)
plot_progress <- c(NA, updates$plot_progress)
true_pk <- unlist(true_pars$pars_pkpd[true_pars$pk_ix])
true_pd <- unlist(true_pars$pars_pkpd[-true_pars$pk_ix])
prior$pars_pkpd <- unlist(prior$pars_pkpd)
prior0 <- prior
dat0 <- NULL
lpr_all <- NULL
for(i in 2:length(update_tms)){
if(print_progress) print(paste("Updating at time t =", update_tms[i]))
prior_pk <- prior$pars_pkpd[prior$pk_ix]
prior_pd <- prior$pars_pkpd[-prior$pk_ix]
# subset targets and observation times to period being updated
targets_sub <- targets[targets$time <= update_tms[i] & targets$time >= update_tms[i-1],]
obs_tms_sub <- obs_tms[obs_tms <= update_tms[i] & obs_tms > update_tms[i-1]]
# calculate tci infusions at prior parameter estimates for update period
inf <- tci_pd(pdresp  = targets_sub$target,
tms     = targets_sub$time,
pdinv   = pdinv,
pdmod   = pdmod,
pkmod   = pkmod,
pars_pk = prior_pk,
pars_pd = prior_pd,
init = init_p,
tci_alg = tci_alg)
# generate data under true model
dat <- gen_data(inf = inf,
tms = obs_tms_sub,
pkmod = pkmod,
pdmod = pdmod,
pars_pk0 = true_pk, # true pk parameters
pars_pd0 = true_pd, # true pd parameters
sigma_add = true_pars$err, # random error
delay = true_pars$delay, # bis delay in minutes
max_pdval = 100,
init = init0)
# merge sampled dataset with prior observations
dat0 <- combine_sim(dat0,dat)
# update parameters based on generated data
# use prior parameter values as starting point - separate fixed parameters
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
# indicate if full dataset should be used for updates
if(update_full[i]){
dat_eval <- dat0
# use full dataset and original vcov matrix
post_est <- nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior0$sig,
fixed_lpr = lpr_fixed,
hessian = FALSE,
steptol=1e-6, gradtol=1e-6, stepmax = 5,
iterlim = 2000)
} else{
dat_eval <- dat
post_est <- nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior$sig,
fixed_lpr = lpr_fixed,
hessian = TRUE,
steptol=1e-6, gradtol=1e-6, stepmax = 5,
iterlim = 2000)
# update vcov matrix
prior$sig <- solve(post_est$hessian)
}
if(plot_progress[i]){
print(plot(dat0, lpars_update = post_est$estimate,
lpars_fixed = log(prior$pars_pkpd[prior$fixed_ix])))
}
# update prior values
if(any(!is.null(prior$fixed_ix))){
prior$pars_pkpd[-prior$fixed_ix] <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
} else{
prior$pars_pkpd <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
}
# update true and predicted initial values
init0 <- dat0$sim[nrow(dat0$sim),grep("c[0-9]",colnames(dat0$sim))]
init_p <- as.numeric(predict(pkmod,
inf = dat0$inf,
tms = update_tms[i],
pars = prior$pars_pkpd[prior$pk_ix],
init = init_start)[-1])
}
# save final posterior parameter values
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
return(list(dat = dat0,
lpr = lpr_all,
posterior = prior,
prior = prior0,
true_pars = true_pars))
}
for(i in 1:nrow(eleveld_pop)){
bayes_sim[[i]] <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list[[i]],
true_pars = true_par_list[[i]])
}
debug(bayes_control)
for(i in 1:nrow(eleveld_pop)){
bayes_sim[[i]] <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list[[i]],
true_pars = true_par_list[[i]])
}
#' @param init0 True initial concentrations
#' @param init_p Predicted initial concentrations
#' @param obs_tms Times at which observations are collected. If null, observations will be
#' made at fixed intervals specified by 'dt'.
#' @param dt Interval between measurements.
#' @param sim_starttm Start time of simulation
#' @param tci_alg TCI algorithm used. Defaults to effect-site targeting.
#' @param print_progress Logical. Should current update times be printed to the console.
#'
#' @export
bayes_control <- function(targets, updates, prior, true_pars,
pkmod = pkmod3cptm, pdmod = emax_eleveld,
pdinv = inv_emax_eleveld,
init0 = NULL, init_p = NULL, obs_tms = NULL,
dt_obs = 1/6, sim_starttm = 0, tci_alg = "effect",
print_progress = FALSE){
# set observation/measurement times
if(is.null(obs_tms)) obs_tms <- seq(dt_obs, max(targets$time), dt_obs)
# set true and predicted initial concentrations if not specified
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init0)) init0 <- rep(0,ncpt)
if(is.null(init_p)) init_p <- rep(0,ncpt)
init_start <- init0
if(is.vector(updates)) updates <- data.frame(time = updates)
if(!("time" %in% names(updates))) stop("dataframe updates must have column named 'time'")
if(!("full_data" %in% names(updates))) updates$full_data <- FALSE
if(!("plot_progress" %in% names(updates))) updates$plot_progress <- FALSE
# add simulation start time to list of update times
update_tms <- c(sim_starttm, updates$time)
update_full <- c(NA, updates$full_data)
plot_progress <- c(NA, updates$plot_progress)
true_pk <- unlist(true_pars$pars_pkpd[true_pars$pk_ix])
true_pd <- unlist(true_pars$pars_pkpd[-true_pars$pk_ix])
prior$pars_pkpd <- unlist(prior$pars_pkpd)
prior0 <- prior
dat0 <- NULL
lpr_all <- NULL
for(i in 2:length(update_tms)){
if(print_progress) print(paste("Updating at time t =", update_tms[i]))
prior_pk <- prior$pars_pkpd[prior$pk_ix]
prior_pd <- prior$pars_pkpd[-prior$pk_ix]
# subset targets and observation times to period being updated
targets_sub <- targets[targets$time <= update_tms[i] & targets$time >= update_tms[i-1],]
obs_tms_sub <- obs_tms[obs_tms <= update_tms[i] & obs_tms > update_tms[i-1]]
# calculate tci infusions at prior parameter estimates for update period
inf <- tci_pd(pdresp  = targets_sub$target,
tms     = targets_sub$time,
pdinv   = pdinv,
pdmod   = pdmod,
pkmod   = pkmod,
pars_pk = prior_pk,
pars_pd = prior_pd,
init = init_p,
tci_alg = tci_alg)
# generate data under true model
dat <- gen_data(inf = inf,
tms = obs_tms_sub,
pkmod = pkmod,
pdmod = pdmod,
pars_pk0 = true_pk, # true pk parameters
pars_pd0 = true_pd, # true pd parameters
sigma_add = true_pars$err, # random error
delay = true_pars$delay, # bis delay in minutes
max_pdval = 100,
init = init0)
# merge sampled dataset with prior observations
dat0 <- combine_sim(dat0,dat)
# update parameters based on generated data
# use prior parameter values as starting point - separate fixed parameters
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
# indicate if full dataset should be used for updates
if(update_full[i]){
dat_eval <- dat0
# use full dataset and original vcov matrix
post_est <- nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior0$sig,
fixed_lpr = lpr_fixed,
hessian = FALSE,
steptol=1e-6, gradtol=1e-6, stepmax = 5,
iterlim = 2000)
} else{
dat_eval <- dat
post_est <- nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior$sig,
fixed_lpr = lpr_fixed,
hessian = TRUE,
steptol=1e-6, gradtol=1e-6, stepmax = 5,
iterlim = 2000)
# update vcov matrix
prior$sig <- solve(post_est$hessian)
}
if(plot_progress[i]){
print(plot(dat0, lpars_update = post_est$estimate,
lpars_fixed = log(prior$pars_pkpd[prior$fixed_ix])))
}
# update prior values
if(any(!is.null(prior$fixed_ix))){
prior$pars_pkpd[-prior$fixed_ix] <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
} else{
prior$pars_pkpd <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
}
# update true and predicted initial values
init0 <- dat0$sim[nrow(dat0$sim),grep("c[0-9]",colnames(dat0$sim))]
init_p <- as.numeric(predict(pkmod,
inf = dat0$inf,
tms = update_tms[i],
pars = prior$pars_pkpd[prior$pk_ix],
init = init_start)[-1])
}
# save final posterior parameter values
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
return(list(dat = dat0,
lpr = lpr_all,
posterior = prior,
prior = prior0,
true_pars = true_pars))
}
for(i in 1:nrow(eleveld_pop)){
bayes_sim[[i]] <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list[[i]],
true_pars = true_par_list[[i]])
}
debug(bayes_control)
for(i in 1:nrow(eleveld_pop)){
bayes_sim[[i]] <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list[[i]],
true_pars = true_par_list[[i]])
}
lpr_all
lpr
dat_eval
lpr
prior0$sig
nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior0$sig,
fixed_lpr = lpr_fixed,
hessian = FALSE,
steptol=1e-6, gradtol=1e-6, stepmax = 5,
iterlim = 2000)
nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior0$sig[[1]],
fixed_lpr = lpr_fixed,
hessian = FALSE,
steptol=1e-6, gradtol=1e-6, stepmax = 5,
iterlim = 2000)
eleveld_vcov(eleveld_pop_prior[i,], N = 100)
eleveld_vcov(eleveld_pop_prior[i,], N = 100)[[1]]
# prior parameter values based on point estimates at covariate values
prior_par_list <- lapply(1:npatients, function(i){
# PK-PD parameters used by Eleveld model
# GAMMA (Hill parameter) has two values depending on the predicted concentration.
# BIS0 is repeated twice corresponding to Emax parameter (E0, Emax)
# see function 'emax_eleveld' for PD response
list(pars_pkpd = eleveld_pop_prior[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0",
"CE50","GAMMA","GAMMA2","BIS0","BIS0")],
pk_ix = 1:9, # indices of PK parameters
fixed_ix = 11:14, # indices of parameters that aren't updated
err = eleveld_pop_prior[i,"SIGMA"], # residual error
sig = eleveld_vcov(eleveld_pop_prior[i,], N = 100)[[1]]) # variance-covariance matrix
})
# true parameter values based on Monte Carlo samples
true_par_list <- lapply(1:npatients, function(i){
list(pars_pkpd = eleveld_pop[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0",
"CE50","GAMMA","GAMMA2","BIS0","BIS0")],
pk_ix = 1:9,
fixed_ix = 11:14,
err = eleveld_pop[i,"SIGMA"],
# delay in BIS observations is assumed to be fixed and known
delay = eleveld_pop_prior[i,"BIS_DELAY"]/60)
})
# data frame of targets
targets = data.frame(time = seq(0,10,1/6),
target = 50)
# data frame of updates - update every two minutes
# use full dataset at each update
# don't plot
updates <- data.frame(time = seq(2,10,2),
full_data = TRUE)
set.seed(1)
bayes_sim <- vector("list", npatients)
for(i in 1:nrow(eleveld_pop)){
bayes_sim[[i]] <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list[[i]],
true_pars = true_par_list[[i]])
}
undebug(bayes_control)
for(i in 1:nrow(eleveld_pop)){
bayes_sim[[i]] <- bayes_control(targets = targets,
updates = updates,
prior = prior_par_list[[i]],
true_pars = true_par_list[[i]])
}
pcl <- lapply(bayes_sim, function(sim) plot(sim$dat,
lpars_update = sim$lpr[nrow(sim$lpr),],
lpars_fixed = log(sim$prior$pars_pkpd[sim$prior$fixed_ix])))
pcl[[1]] + geom_hline(yintercept = c(50,40,60), linetype = c("solid","dotted","dotted"))
pcl <- lapply(bayes_sim, function(sim){
plot(sim$dat,
lpars_update = sim$lpr[nrow(sim$lpr),],
lpars_fixed = log(sim$prior$pars_pkpd[sim$prior$fixed_ix])) +
geom_hline(yintercept = c(50,40,60), linetype = c("solid","dotted","dotted"))
})
pcl[[2]]
pcl[[3]]
pcl[[4]]
pcl[[5]]
?gridExtra::grid.arrange
gridExtra::grid.arrange(pcl[[1]], pcl[[2]], pcl[[3]], pcl[[4]], pcl[[5]], nrow = 3)
gridExtra::grid.arrange(pcl, nrow = 3)
gridExtra::grid.arrange(grobs = pcl, nrow = 3)
# Access Eleveld et al. (2018) data
data(eleveld_pk)
# true patient parameters - MC samples
npatients <- 4
set.seed(1)
eleveld_pop <- eleveld_poppk(eleveld_pk[1:npatients,],
rate = TRUE,
rand = TRUE)
# prior patient parameters
eleveld_pop_prior <- eleveld_poppk(eleveld_pk[1:npatients,],
rate = TRUE,
rand = FALSE)
## Calculate infusions to reach BIS = 50
fixed_tci_pop <- lapply(1:nrow(eleveld_pop_prior), function(i){
# tci infusions are calculated using prior parameter estimates
pars_pki <- unlist(eleveld_pop_prior[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pdi <- unlist(eleveld_pop_prior[i,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
out <- tci_pd(pdresp = c(50,50),
tms = c(0,5),
pdinv = inv_emax_eleveld,
pdmod = emax_eleveld,
pkmod = pkmod3cptm,
pars_pk = pars_pki,
pars_pd = pars_pdi)
out <- cbind(id = i, out)
out
})
## generate observed data
fixed_tci_datasim <- vector("list", nrow(eleveld_pop))
for(i in 1:nrow(eleveld_pop)){
# generate data based on "true" parameter values
pars_pki0 <- unlist(eleveld_pop[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pdi0 <- unlist(eleveld_pop[i,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
# fixed bis target
fixed_tci_datasim[[i]] <- gen_data(inf = fixed_tci_pop[[i]],
pkmod = pkmod3cptm,
pdmod = emax_eleveld,
pars_pk0 = pars_pki0, # true pk parameters
pars_pd0 = pars_pdi0, # true pd parameters
sigma_add = eleveld_pop[i,"SIGMA"], # random error
delay = eleveld_pop[i,"BIS_DELAY"], # bis delay
init = c(0,0,0,0))
fixed_tci_datasim[[i]]$sim <- cbind(id = i, fixed_tci_datasim[[i]]$sim)
}
# subset and format for plotting
fixed_pop_df <- as.data.frame(
do.call("rbind",
lapply(fixed_tci_pop, function(x)
x[,c("id","begin","pdt","pdresp_start")])
)
)
fixed_tci_datasim_df <- subset(
as.data.frame(do.call("rbind", lapply(fixed_tci_datasim, `[[`, "sim"))),
select = c(id,time,pd0,pdobs)
)
library(ggplot2)
ggplot(fixed_pop_df, aes(x = begin, y = pdresp_start, group = id)) +
geom_line(aes(x = begin, y = pdt, group = id, color = "Target"),
size = 1.2) +
geom_line(alpha = 0.6, aes(color = "Predicted")) +
geom_line(data = fixed_tci_datasim_df,
aes(x = time, y = pd0, group = id, color = "Observed"),
alpha = 0.6) +
lims(y = c(0,100)) +
scale_color_manual(name = "",
values = c("Target"    = unname(pal[1]),
"Predicted" = unname(pal[2]),
"Observed"  = unname(pal[5]))) +
labs(x = "Minutes", y = "Bispectral Index")
bayes_sim <- bayes_sim[1:4]
pcl <- lapply(bayes_sim, function(sim){
plot(sim$dat,
lpars_update = sim$lpr[nrow(sim$lpr),],
lpars_fixed = log(sim$prior$pars_pkpd[sim$prior$fixed_ix])) +
geom_hline(yintercept = c(50,40,60), linetype = c("solid","dotted","dotted"))
})
gridExtra::grid.arrange(grobs = pcl, nrow = 2)
plot.datasim
library(tci)
# install most recent version from github
devtools::install_github("jarretrt/tci")
library(tci)
eleveld_vcov
?eleveld_vcov
??eleveld_vcov
eleveld_theta_pd_est <- c(3.08,0.146,93.0,1.47,8.03,0.0517,-0.00635,1.24,1.89)
eleveld_eta_pd_var <- c(0.242,0.702,0.230)
vars <- c("AGE","WGT","HGT","M1F2","PMA","TECH","A1V2")
patient_covariates <- subset(eleveld_pd, ID == 403, select = vars)
data(eleveld_pd)
patient_covariates <- subset(eleveld_pd, ID == 403, select = vars)
eta_obs <- c(mvtnorm::rmvnorm(1,sigma = diag(eleveld_eta_pd_var)))
gen_eleveld_pd_pars(theta = eleveld_theta_pd_est,
eta = eleveld_eta_pd_var,
patient_vars = patient_covariates)
library(tci)
gen_eleveld_pd_pars(theta = eleveld_theta_pd_est,
eta = eleveld_eta_pd_var,
patient_vars = patient_covariates)
library(tci)
library(tci)
library(tci)
library(tci)
data(eleveld_pd)
data(eleveld_pk)
patient_covariates <- subset(eleveld_pk, ID == 403, select = c("AGE","WGT","HGT","M1F2","PMA","TECH","A1V2"))
patient_covariates
c(mvtnorm::rmvnorm(1,sigma = diag(eleveld_eta_pk_var)))
eleveld_eta_pk_var <- c(0.610,0.565,0.597,0.265,0.346,0.209,0.463)
eta_obs <- c(mvtnorm::rmvnorm(1,sigma = diag(eleveld_eta_pk_var)))
gen_eleveld_pk_pars_nonmem(THETA = eleveld_theta_pk_est,
ETA = eta_obs,
PATIENT_VARS = patient_covariates)
eleveld_theta_pk_est <- c(6.28,25.5,273,1.79,1.75,1.11,0.191,42.3,9.06,-0.0156,-0.00286,33.6,-0.0138,68.3,2.10,1.30,1.42,0.68)
gen_eleveld_pk_pars_nonmem(THETA = eleveld_theta_pk_est,
ETA = eta_obs,
PATIENT_VARS = patient_covariates)
library(tci)
library(tci)
library(tci)
library(tci)
library(tci)
library(tci)
library(tci)
library(tci)
library(tci)
?cut
inv_emax
library(tci)
