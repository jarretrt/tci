pkmod = pkmod3cptm,
pars_pd = pars_emax,
pars_pk = pars_3cpt,
inf = create_intvl(data.frame(time = c(2,4,6,10),
infrt = c(400,0,400,0))),
title = "Predicted PK-PD responses")
tci_pd
tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
bist <- c(40,50,70,70)
tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
#' The user passes the `iterate_tci` function a matrix of target concentrations and times
#' at which the target is set. This is translated into a step function that defines the
#' concentration target at all times.
#'
#' @param Ct Vector of target concentrations
#' @param tms Times at which the TCI algorithm should try to achieve the target concentrations
#' @param tci TCI algorithm. Options are provided for effect-site (default) or plasma targeting.
#' Alternate algorithms can be specified through the 'tci_custom' argument.
#' @param
#'
iterate_tci_grid <- function(Ct, tms, pkmod, pars, init = NULL,
# tci = tci_plasma,
tci = c("effect","plasma"),
inittm = 0, dt = 1/6, tci_custom = NULL, ...){
tci <- match.arg(tci)
if(!is.null(tci_custom)){
tci <- tci_custom
} else{
if(tci == "effect") tci <- tci_comb
else tci <- tci_plasma
}
# adjust times such that infusions start at tm = 0
tms <- tms - inittm
# create step function to define targets at any point
sf <- stepfun(tms, Ct)
# define sequence of update times
updatetms <- seq(0, max(tms)-dt, dt)
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init)) init <- rep(0,ncpt)
inf <- matrix(NA, nrow = length(updatetms), ncol = 2)
ini <- matrix(NA, nrow = ncpt, ncol = length(updatetms)+1)
ini[,1] <- init
browser()
# iterate through times
for(i in 1:length(updatetms)){
inf[i,] <- tci(sf(updatetms[i]), pkmod = pkmod, pars = pars, dt = dt, init = ini[,i], ...)
ini[,i+1] <- pkmod(tm = dt, kR = inf[i,1], pars = pars, init = ini[,i])
}
startcon <- data.frame(matrix(ini[,-ncol(ini)], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
endcon <- data.frame(matrix(ini[,-1], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
out <- create_intvl(dose = data.frame(time = seq(dt, max(tms), dt), infrt = inf[,1]), inittm = inittm)
out <- cbind(out, inf[,2], sf(updatetms), startcon, endcon)
names(out) <- c("intvl","infrt","begin","end","dt","Ct",paste0("c",1:ncpt, "_start"), paste0("c",1:ncpt, "_end"))
class(out) <- c("tciinf",class(out))
return(out)
}
tci_bis_res <- tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
updatetms
i = 1
tci(sf(updatetms[i]), pkmod = pkmod, pars = pars, dt = dt, init = ini[,i], ...)
tci_bis_res <- tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
updatetms[i]
i = 1
updatetms[i]
pkmod
pars
sf(updatetms[i])
sf
tms
i = 2
sf(updatetms[i])
updatetms[i]
updatetms
i = 79
sf(updatetms[i])
sf
stepfun
?stepfun
sf2 <- stepfun(tms, Ct, right = T)
sf2(updatetms[1])
sf2(updatetms[2])
sf2
sf
Ct
tci_pd
#' The user passes the `iterate_tci` function a matrix of target concentrations and times
#' at which the target is set. This is translated into a step function that defines the
#' concentration target at all times.
#'
#' @param Ct Vector of target concentrations
#' @param tms Times at which the TCI algorithm should try to achieve the target concentrations
#' @param tci TCI algorithm. Options are provided for effect-site (default) or plasma targeting.
#' Alternate algorithms can be specified through the 'tci_custom' argument.
#' @param
#'
iterate_tci_grid <- function(Ct, tms, pkmod, pars, init = NULL,
# tci = tci_plasma,
tci = c("effect","plasma"),
inittm = 0, dt = 1/6, tci_custom = NULL, ...){
tci <- match.arg(tci)
if(!is.null(tci_custom)){
tci <- tci_custom
} else{
if(tci == "effect") tci <- tci_comb
else tci <- tci_plasma
}
# adjust times such that infusions start at tm = 0
tms <- tms - inittm
# create step function to define targets at any point
sf <- stepfun(tms, Ct)
# define sequence of update times
updatetms <- seq(0, max(tms)-dt, dt)
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init)) init <- rep(0,ncpt)
inf <- matrix(NA, nrow = length(updatetms), ncol = 2)
ini <- matrix(NA, nrow = ncpt, ncol = length(updatetms)+1)
ini[,1] <- init
# iterate through times
for(i in 1:length(updatetms)){
inf[i,] <- tci(sf(updatetms[i]), pkmod = pkmod, pars = pars, dt = dt, init = ini[,i], ...)
ini[,i+1] <- pkmod(tm = dt, kR = inf[i,1], pars = pars, init = ini[,i])
}
startcon <- data.frame(matrix(ini[,-ncol(ini)], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
endcon <- data.frame(matrix(ini[,-1], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
out <- create_intvl(dose = data.frame(time = seq(dt, max(tms), dt), infrt = inf[,1]), inittm = inittm)
out <- cbind(out, inf[,2], sf(updatetms), startcon, endcon)
names(out) <- c("intvl","infrt","begin","end","dt","Ct",paste0("c",1:ncpt, "_start"), paste0("c",1:ncpt, "_end"))
class(out) <- c("tciinf",class(out))
return(out)
}
debug(tci_pd)
tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
pdresp
pars_pd
pdinv
pdresp
#' Inverse Emax function that assumes Emx = E0
#' @param pdresp PD response values
#' @param pars Named vector of parameter values with names (c50,gamma,E0,Emx).
inv_emax <- function(pdresp, pars){
eff <- abs(pdresp - pars["E0"])
(eff*(pars["c50"]^pars["gamma"])/(pars["Emx"]*(1-eff/pars["Emx"])))^(1/pars["gamma"])
}
#' pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
ce_seq <- seq(0,4,0.1)
all.equal(inv_emax(emax(ce_seq, pars_emax), pars_emax), ce_seq)
tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
pdresp
pars_pd
pdinv(pdresp, pars_pd)
undebug(tci_pd)
tci_bis_res <- tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
head(tci_bis_res)
tci_bis_res
View(tci_bis_res)
# plot TCI object
plot(tci_3cpt_effect)
# plot TCI object with PD response
plot(tci_bis_res)
# plot TCI object
grid.arrange(plot(tci_3cpt_effect), plot(tci_bis_res))
# plot TCI object
grid.arrange(plot(tci_3cpt_effect), plot(tci_bis_res), ncol = 2)
plot(pdmod = emax,
pkmod = pkmod3cptm,
pars_pd = pars_emax,
pars_pk = pars_3cpt,
inf = create_intvl(data.frame(time = c(2,4,6,10),
infrt = c(400,0,400,0))),
title = "Predicted PK-PD responses")
# new set of PK parameters for 3 compartment model
pars_3cpt0 <- c(k10=1.7,k12=0.13,k21=0.1,k13=0.8,k31=0.8,v1=15,v2=16,v3=90,ke0=1.2)
# generate PK data sampled each minute with multiplicative error
pkdsim <- gen_data(inf = create_intvl(dose), pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0,
tms = seq(0,10,1), sigma.mult = 0.5)
head(pkdsim$sim)
# generate PK data for infusions starting at time t=10 using
# final concentrations from prior simulation as initial values
dosetm10 <- dose
dosetm10$time  <- dosetm10$time+10
inittm10 <- unlist(tail(pkdsim$sim[,c("c1","c2","c3","c4")], 1))
pkdsimtm10 <- gen_data(inf = create_intvl(dosetm10, inittm = 10),
pkmod = pkmod3cptm,
pars_pk0 = pars_3cpt0,
tms = seq(10,20,1),
sigma.mult = 0.5,
init = inittm10)
head(pkdsimtm10$sim)
# new set of PD parameters for Emax model
pars_emax0 <- c(c50 = 1.2, gamma = 3.5, E0 = 100, Emx = 100)
# Simulate PK-PD data under model misspecification.
# Predicted concentrations / responses under model with pars "pars_3cpt", "pars_emax"
tci_bis_res <- tci_pd(pdresp = c(40,50,70,70),
tms = c(5,10,15),
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
# Generate data using infusion schedule above under a different PK-PD model
pkpddsim <- gen_data(inf = tci_bis_res,
pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0,
pdmod = emax, pars_pd0 = pars_emax0,
sigma.add = 7, delay = 15/60, max_pdval = 100)
head(pkpddsim$sim)
# Generate data at time t=15 with new targets and starting concentrations
tci_bis_res_init <- tci_pd(pdresp = c(40,50,70,70),
tms = c(5,10,15)+15,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax,
init = unlist(tail(
pkpddsim$inf[,c("c1_end","c2_end","c3_end","c4_end")]
,1)),
inittm = 15
)
# pass in true concentrations as starting concentrations
pkpddsim_init <- gen_data(inf = tci_bis_res_init,
pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0,
pdmod = emax, pars_pd0 = pars_emax0,
sigma.add = 7, delay = 15/60, max_pdval = 100,
init = unlist(tail(
pkpddsim$sim[,c("c1","c2","c3","c4")]
,1)))
head(pkpddsim_init$sim)
p1 <- plot(pkpddsim)
p2 <- plot(pkpddsim_init)
p12 <- plot(combine_sim(pkpddsim, pkpddsim_init))
grid.arrange(p1,p2,p12)
grid.arrange(p1,p2,p12, ncol = 2)
matrix(c(1,3,2,3),2,2)
grid.arrange(p1,p2,p12, lay = matrix(c(1,3,2,3),2,2))
grid.arrange(p1,p2,p12, layout_matrix = matrix(c(1,3,2,3),2,2))
dat <- data.frame(AGE  = c(20,40,65),
TBM  = c(50,70,90),
HGT  = c(150,170,200),
MALE = c(TRUE,FALSE,TRUE))
identical(schnider_poppk(dat, rand = F, rate = F), apply_poppk(dat, "schnider"))
# Simulate PK-PD for patients based on eleveld data
data(eleveld_pk)
eleveld_poppk(eleveld_pk[1:5,], rate = T) # pk data only with rate parameters
eleveld_poppk(eleveld_pk[1:5,], rate = F, PD = T, rand = T) # pk-pd data with clearance parameters and random error
tms_sigmoid <- seq(0,10,1/6) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute
# parameters of Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
# apply inverse
sig_tci_targets <- tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
tci_pd
debug(tci_pd)
targets_sigmoid
restrict_sigmoid(1)
tms_sigmoid
emax
debugonce(emax)
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute
pars["E0"]
pars
restrict_sigmoid
#' Function to place restriction on gamma and E50 parameters of target sigmoid
#' such that it passes through point (tfinal, BISfinal+eps)
restrict_sigmoid <- function(t50, tfinal =10, eps = 1, BIS0 = 100, BISfinal = 50){
gamma <- log((BIS0-BISfinal)/eps + 1, base = tfinal/t50)
c(c50 = t50, gamma = gamma, E0 = BIS0, Emx = BIS0 - BISfinal)
}
emax(tms_sigmoid, restrict_sigmoid(1))
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute
# parameters of Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
# apply inverse
sig_tci_targets <- tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
undebug(tci_pd)
# apply inverse
sig_tci_targets <- tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
x
y
length(x)
length(y)
tci_pd
#' Function to extend TCI grid to a set of PD targets
tci_pd <- function(pdresp, tms, pkmod, pdmod, pars_pk, pars_pd, pdinv, ecmpt = NULL, ...){
Ct <- pdinv(pdresp, pars_pd)
con <- iterate_tci_grid(Ct = Ct, tms = tms, pkmod = pkmod, pars = pars_pk, ...)
if(is.null(ecmpt))
ecmpt <- length(eval(formals(pkmod)$init))
con$pdt <- pdmod(con$Ct, pars_pd)
con$pdresp <- pdmod(con[,paste0("c",ecmpt,"_start")], pars_pd)
return(con)
}
source("./R/misc_functions.R") # miscellaneous functions unrelated to pkpd modeling
source("./R/pk_mods.R") # library of pk models
source("./R/pd_mods.R") # library of pd models
source("./R/pkpd_assist.R") # functions related to pkpd modeling
source("./R/tci_algorithms.R") # functions implementing TCI algorithms
source("./R/simulations.R") # functions implementing TCI simulations
source("./R/poppk_mods.R") # pre-saved population PK and PK-PD models
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
tci_pd
debug(tci_pd)
targets_sigmoid
tms_sigmoid
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
pdinv(pdresp, pars_pd)
tms
length(tms)
length(Ct)
pkmod
iterate_tci_grid(Ct = Ct, tms = tms, pkmod = pkmod, pars = pars_pk, ...)
undebug(tci_pd)
debug(interate_tci_grid)
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
undebug(tci_pd)
debug(interate_tci_grid)
debug(iterate_tci_grid)
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
tci
tci
inittm
tms - inittm
Ct
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
length(tms)
length(Ct)
tms
Ct
?stepfun
tms_sigmoid <- seq(1/6,10,1/6) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute
# parameters of Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
tci_pd
iterate_tci_grid
#' The user passes the `iterate_tci` function a matrix of target concentrations and times
#' at which the target is set. This is translated into a step function that defines the
#' concentration target at all times.
#'
#' @param Ct Vector of target concentrations
#' @param tms Times at which the TCI algorithm should try to achieve the target concentrations
#' @param tci TCI algorithm. Options are provided for effect-site (default) or plasma targeting.
#' Alternate algorithms can be specified through the 'tci_custom' argument.
#' @param
#'
iterate_tci_grid <- function(Ct, tms, pkmod, pars, init = NULL,
# tci = tci_plasma,
tci = c("effect","plasma"),
inittm = 0, dt = 1/6, tci_custom = NULL, ...){
tci <- match.arg(tci)
if(!is.null(tci_custom)){
tci <- tci_custom
} else{
if(tci == "effect") tci <- tci_comb
else tci <- tci_plasma
}
# adjust times such that infusions start at tm = 0
tms <- tms - inittm
# create step function to define targets at any point
if(length(tms) == length(Ct)) {
warning("Assuming that first time corresponds to initial values and dropping from calculation.")
tms <- tms[-1]
}
sf <- stepfun(tms, Ct)
# define sequence of update times
updatetms <- seq(0, max(tms)-dt, dt)
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init)) init <- rep(0,ncpt)
inf <- matrix(NA, nrow = length(updatetms), ncol = 2)
ini <- matrix(NA, nrow = ncpt, ncol = length(updatetms)+1)
ini[,1] <- init
# iterate through times
for(i in 1:length(updatetms)){
inf[i,] <- tci(sf(updatetms[i]), pkmod = pkmod, pars = pars, dt = dt, init = ini[,i], ...)
ini[,i+1] <- pkmod(tm = dt, kR = inf[i,1], pars = pars, init = ini[,i])
}
startcon <- data.frame(matrix(ini[,-ncol(ini)], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
endcon <- data.frame(matrix(ini[,-1], ncol = nrow(ini), nrow = ncol(ini)-1, byrow = T))
out <- create_intvl(dose = data.frame(time = seq(dt, max(tms), dt), infrt = inf[,1]), inittm = inittm)
out <- cbind(out, inf[,2], sf(updatetms), startcon, endcon)
names(out) <- c("intvl","infrt","begin","end","dt","Ct",paste0("c",1:ncpt, "_start"), paste0("c",1:ncpt, "_end"))
class(out) <- c("tciinf",class(out))
return(out)
}
tms_sigmoid <- seq(0,10,1/6) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute
# parameters of Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
# apply inverse
sig_tci_targets <- tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
undebug(tci_comb)
undebug(tci_comb)
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
tms_sigmoid <- seq(0,10,1/6) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1)) # parameters restricted to reach mid point at t=1 minute
# parameters of Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, E0 = 100, Emx = 100)
tci_pd
undebug(iterate_tci_grid)
debug(iterate_tci_grid)
tci_pd(pdresp = targets_sigmoid,
tms = tms_sigmoid,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
tms
stepfun(tms, Ct)
updatetms
