delay = eleveld_pop[i,"BIS_DELAY"], # bis delay
max_pdval = 100,
init = c(0,0,0,0))
fixed_tci_datasim[[i]]$sim <- cbind(id = i, fixed_tci_datasim[[i]]$sim)
fixed_tci_datasim[[i]]
for(i in 1:nrow(eleveld_pop)){
# generate data based on "true" parameter values
pars_pki0 <- unlist(eleveld_pop[i,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pdi0 <- unlist(eleveld_pop[i,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pdi0) <- c("c50","gamma","gamma2","e0","emx")
# fixed bis target
fixed_tci_datasim[[i]] <- gen_data(inf = fixed_tci_pop[[i]],
pkmod = pkmod3cptm,
pdmod = emax_eleveld,
pars_pk0 = pars_pki0, # true pk parameters
pars_pd0 = pars_pdi0, # true pd parameters
sigma_add = eleveld_pop[i,"SIGMA"], # random error
delay = eleveld_pop[i,"BIS_DELAY"], # bis delay
max_pdval = 100,
init = c(0,0,0,0))
fixed_tci_datasim[[i]]$sim <- cbind(id = i, fixed_tci_datasim[[i]]$sim)
# sigmoid target
sig_tci_datasim[[i]] <- gen_data(inf = sig_tci_pop[[i]],
pkmod = pkmod3cptm,
pdmod = emax_eleveld,
pars_pk0 = pars_pki0, # true pk parameters
pars_pd0 = pars_pdi0, # true pd parameters
sigma_add = eleveld_pop[i,"SIGMA"], # random error
delay = eleveld_pop[i,"BIS_DELAY"], # bis delay
max_pdval = 100,
init = c(0,0,0,0))
sig_tci_datasim[[i]]$sim <- cbind(id = i, sig_tci_datasim[[i]]$sim)
}
fixed_tci_datasim_df <- subset(
as.data.frame(do.call("rbind", lapply(fixed_tci_datasim, `[[`, "sim"))),
select = c(id,time,pd0,pdobs)
)
sig_tci_datasim_df <- subset(
as.data.frame(do.call("rbind", lapply(sig_tci_datasim, `[[`, "sim"))),
select = c(id,time,pd0,pdobs)
)
p3 <- ggplot(fixed_pop_df, aes(x = begin, y = pdresp_start, group = id)) +
geom_line(aes(x = begin, y = pdt, group = id, color = "Target"),
size = 1.2) +
geom_line(alpha = 0.6, aes(color = "Predicted")) +
geom_line(data = fixed_tci_datasim_df,
aes(x = time, y = pd0, group = id, color = "Observed"),
alpha = 0.6) +
lims(y = c(0,100)) +
scale_color_manual(name = "",
values = c("Target"    = unname(pal[1]),
"Predicted" = unname(pal[2]),
"Observed"  = unname(pal[5])))
p3
p4 <- ggplot(sig_pop_df, aes(x = begin, y = pdresp_start, group = id)) +
geom_line(aes(x = begin, y = pdt, group = id, color = "Target"),
size = 1.2) +
geom_line(alpha = 0.6, aes(color = "Predicted")) +
geom_line(data = sig_tci_datasim_df,
aes(x = time, y = pd0, group = id, color = "Observed"),
alpha = 0.6) +
lims(y = c(0,100)) +
scale_color_manual(name = "",
values = c("Target"    = unname(pal[1]),
"Predicted" = unname(pal[2]),
"Observed"  = unname(pal[5])))
p4
grid.arrange(p1, p2, p3, p4, ncol = 2)
grid.arrange(p3, p4)
# update after 5 minutes of following sigmoid targets with observations collected every second
starttm = 0; endtm = 5; dt_obs = 1/6; dt_tci = 1/60
tms_sigmoid <- seq(starttm,endtm,dt_tci) # 10 minute induction with target sigmoid
targets_sigmoid <- emax(tms_sigmoid, restrict_sigmoid(1, BIS0 = 93)) # parameters restricted to reach mid point at t=1 minute
# prior pk-pd parameters for 1st patient in Eleveld dataset
pars_pk_prior <- unlist(eleveld_pop_prior[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_prior <- unlist(eleveld_pop_prior[1,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_prior) <- c("c50","gamma","gamma2","e0","emx")
# prior distribution hyperparameters
# the 'elvdlpars' function extracts the pk-pd parameters from the Eleveld dataset
lpr_eval <- elvdlpars(eleveld_pop_prior[1,])
mu0 <- elvdlpars(eleveld_pop[1,])
sig0 <- poppk_cov("Eleveld")
# Calculate tci infusions at prior parameter estimates
inf <- tci_pd(pdresp  = targets_sigmoid,
tms     = tms_sigmoid,
pdinv   = inv_emax_eleveld,
pdmod   = emax_eleveld,
pkmod   = pkmod3cptm,
pars_pk = pars_pk_prior,
pars_pd = pars_pd_prior)
# expected time course under correct model specification
plot(inf)
# true pk-pd parameters for patient
pars_pk_true <- unlist(eleveld_pop[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_true <- unlist(eleveld_pop[1,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
# simulate data based on true pk-pd parameters
# generate observations every second
tms_obs <- seq(dt_obs,endtm,dt_obs)
dat <- gen_data(inf = inf,
tms = tms_obs,
pkmod = pkmod3cptm,
pdmod = emax_eleveld,
pars_pk0 = pars_pk_true, # true pk parameters
pars_pd0 = pars_pd_true, # true pd parameters
sigma_add = eleveld_pop[1,"SIGMA"], # random error
delay = eleveld_pop[1,"BIS_DELAY"]/60, # bis delay in minutes
max_pdval = 100,
init = c(0,0,0,0))
# fixed parameters that need to be used, but aren't evaluated in likelihood
# ordering of parameters is important to correct use of PD function
fixed_lpr <- log(as.numeric(eleveld_pop_prior[1,c("GAMMA","GAMMA2","BIS0","BIS0")]))
plot(dat)
# fixed parameters that need to be used, but aren't evaluated in likelihood
# ordering of parameters is important to correct use of PD function
fixed_lpr <- log(as.numeric(eleveld_pop_prior[1,c("GAMMA","GAMMA2","BIS0","BIS0")]))
# update parameter estimates with data
post_est <- nlm(f = log_posterior_neg,
p = unname(elvdlpars(eleveld_pop_prior[1,])),
dat = dat,
mu = unname(elvdlpars(eleveld_pop[1,])),
sig = poppk_cov("Eleveld"),
fixed_lpr = fixed_lpr,
hessian = T)
plot(dat, lpars_update = post_est$estimate, lpars_fixed = fixed_lpr)
# prior pk parameters for 1st patient in Eleveld dataset
pars_pk_prior <- unlist(eleveld_pop_prior[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0","LN_SIGMA")])
# true pk-pd parameters for patient
pars_pk_true <- unlist(eleveld_pop[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0","LN_SIGMA")])
# pass in values to be targeted at each time
inf <- tci(Ct    = c(2,3,3),
tms   = c(0,5,10),
pkmod = pkmod3cptm,
pars  = pars_pk_prior)
# plot infusion schedule with predicted concentrations
plot(inf)
# parameter estimates and prior mean/covariance
lpr_eval <- elvdlpars(eleveld_pop_prior[1,], pd = F)
mu0 <- elvdlpars(eleveld_pop[1,], pd = F)
sig0 <- poppk_cov("Eleveld", pd = F)
# simulate data based on true pk parameters
# generate observations every minute
set.seed(1)
dat <- gen_data(inf = inf,
tms = 1:10,
pkmod = pkmod3cptm,
pars_pk0 = pars_pk_true, # true pk parameters
sigma_add = eleveld_pop[1,"LN_SIGMA"], # random error
log_err = TRUE,
init = c(0,0,0,0))
plot(dat)
# prior pk parameters for 1st patient in Eleveld dataset
pars_pk_prior <- unlist(eleveld_pop_prior[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0","LN_SIGMA")])
# true pk-pd parameters for patient
pars_pk_true <- unlist(eleveld_pop[1,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0","LN_SIGMA")])
# pass in values to be targeted at each time
inf <- tci(Ct    = c(2,3,3),
tms   = c(0,5,10),
pkmod = pkmod3cptm,
pars  = pars_pk_prior)
# plot infusion schedule with predicted concentrations
plot(inf)
# parameter estimates and prior mean/covariance
lpr_eval <- elvdlpars(eleveld_pop_prior[1,], pd = F)
mu0 <- elvdlpars(eleveld_pop[1,], pd = F)
sig0 <- poppk_cov("Eleveld", pd = F)
# simulate data based on true pk parameters
# generate observations every minute
set.seed(1)
dat <- gen_data(inf = inf,
tms = 1:10,
pkmod = pkmod3cptm,
pars_pk0 = pars_pk_true, # true pk parameters
sigma_add = eleveld_pop[1,"LN_SIGMA"], # random error
log_err = TRUE,
init = c(0,0,0,0))
post_est <- nlm(f = log_posterior_neg,
p = lpr_eval,
dat = dat,
mu = mu0,
sig = sig0,
pd_ix = NULL,
err_ix = 10,
hessian = T)
plot(dat, lpars_update = post_est$estimate)
# simulate for patient 1
id = 1
# prior parameters
eleveld_pop_prior <- eleveld_poppk(eleveld_pk[id,], rate = T, PD = T, rand = F)
pars_pk_prior <- unlist(eleveld_pop_prior[id,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_prior <- unlist(eleveld_pop_prior[id,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_prior) <- c("c50","gamma","gamma2","e0","emx")
# simulate true patient parameters
set.seed(1)
eleveld_pop <- eleveld_poppk(eleveld_pk[id,], rate = T, PD = T, rand = T)
pars_pk_true <- unlist(eleveld_pop[id,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_true <- unlist(eleveld_pop[id,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_true) <- c("c50","gamma","gamma2","e0","emx")
# list for prior distribution parameters
prior <- list(pars_pkpd = c(pars_pk_prior,pars_pd_prior),
pk_ix = 1:9,
fixed_ix = 11:14,
err = eleveld_pop_prior[id,"SIGMA"],
sig = poppk_cov("Eleveld"))
# list for prior distribution parameters
# information regarding which parameters should be updated is taken from prior object
true_pars <- list(pars_pkpd = c(pars_pk_true, pars_pd_true),
pk_ix = 1:9,
fixed_ix = 11:14,
err = eleveld_pop[id,"SIGMA"],
delay = eleveld_pop_prior[id,"BIS_DELAY"]/60)
# update after 10 minutes of following sigmoid targets with adjustments made every 10 seconds
# and BIS observations collected each second
starttm = 0; endtm = 10; dt_obs = 1/60; dt_tci = 1/6
tms_sigmoid <- seq(starttm,endtm,dt_tci) # 10 minute induction with target sigmoid
targets <- data.frame(time = tms_sigmoid,
target =  emax(tms_sigmoid, restrict_sigmoid(1, BIS0 = 93)))
targets
updates
# specify times of updates and whether the full dataset should be used or only
# the most recently collected samples - full updates for first three minutes, followed
# by partial updates for the remaining seven.
updates <- data.frame(time = 1:10, full_data = c(rep(TRUE,3), rep(FALSE,7)))
updates
prior
true_pars
bayes_control
tci_pd
tci_pd
tci
bayes_control
# simulate for patient 1
id = 1
# prior parameters
eleveld_pop_prior <- eleveld_poppk(eleveld_pk[id,], rate = T, PD = T, rand = F)
pars_pk_prior <- unlist(eleveld_pop_prior[id,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_prior <- unlist(eleveld_pop_prior[id,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_prior) <- c("c50","gamma","gamma2","e0","emx")
# simulate true patient parameters
set.seed(1)
eleveld_pop <- eleveld_poppk(eleveld_pk[id,], rate = T, PD = T, rand = T)
pars_pk_true <- unlist(eleveld_pop[id,c("K10","K12","K21","K13","K31","V1","V2","V3","KE0")])
pars_pd_true <- unlist(eleveld_pop[id,c("CE50","GAMMA","GAMMA2","BIS0","BIS0")])
names(pars_pd_true) <- c("c50","gamma","gamma2","e0","emx")
# list for prior distribution parameters
prior <- list(pars_pkpd = c(pars_pk_prior,pars_pd_prior),
pk_ix = 1:9,
fixed_ix = 11:14,
err = eleveld_pop_prior[id,"SIGMA"],
sig = poppk_cov("Eleveld"))
# list for prior distribution parameters
# information regarding which parameters should be updated is taken from prior object
true_pars <- list(pars_pkpd = c(pars_pk_true, pars_pd_true),
pk_ix = 1:9,
fixed_ix = 11:14,
err = eleveld_pop[id,"SIGMA"],
delay = eleveld_pop_prior[id,"BIS_DELAY"]/60)
# update after 10 minutes of following sigmoid targets with adjustments made every 10 seconds
# and BIS observations collected each second
starttm = 0; endtm = 10; dt_obs = 1/60; dt_tci = 1/6
tms_sigmoid <- seq(starttm,endtm,dt_tci) # 10 minute induction with target sigmoid
targets <- data.frame(time = tms_sigmoid,
target =  emax(tms_sigmoid, restrict_sigmoid(1, BIS0 = 93)))
# specify times of updates and whether the full dataset should be used or only
# the most recently collected samples - full updates for first three minutes, followed
# by partial updates for the remaining seven.
updates <- data.frame(time = 1:10, full_data = c(rep(TRUE,3), rep(FALSE,7)))
set.seed(2)
bayes_sim <- bayes_control(targets = targets,
updates = updates,
prior = prior,
true_pars = true_pars,
plot_progres = TRUE)
updates
#' Function to provide Bayesian closed-loop control to
#' @param targets Dataframe with columns ("time","target")
#' @param updates Dataframe of times at which closed-loop updates should be conducted and
#' optional variable with logical values named 'full_data' indicating if full updates should
#' be used. Defaults to partial.
#' @param prior List with elements "mu" and "sig" specifying the prior mean and covariance
#' matrices for the logged parameter values.
#' @param obs_tms Times at which observations are collected. If null, observations will be
#' made at fixed intervals specified by 'dt'.
#' @param dt Interval between measurements.
bayes_control <- function(targets, updates, prior, true_pars,
pkmod = pkmod3cptm, pdmod = emax_eleveld, pdinv = inv_emax_eleveld,
init0 = NULL, init_p = NULL, obs_tms = NULL, dt = 1/60, sim_starttm = 0,
tci_alg = "effect"){
# set observation/measurement times
if(is.null(obs_tms)) obs_tms <- seq(dt, max(targets$time), dt)
# set true and predicted initial concentrations if not specified
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init0)) init0 <- rep(0,ncpt)
if(is.null(init_p)) init_p <- rep(0,ncpt)
if(is.vector(updates)) updates <- data.frame(time = updates)
if("time" %nin% names(updates)) stop("dataframe updates must have column named 'time'")
if("full_data" %nin% names(updates)) updates$full_data <- FALSE
if("plot" %nin% names(updates)) updates$plot <- FALSE
# add simulation start time to list of update times
update_tms <- c(sim_starttm, updates$time)
update_full <- c(NA, updates$full_data)
plot_progress <- c(NA, updates$plot_progress)
true_pk <- true_pars$pars_pkpd[true_pars$pk_ix]
true_pd <- true_pars$pars_pkpd[-true_pars$pk_ix]
prior0 <- prior
dat0 <- NULL
lpr_all <- NULL
for(i in 2:length(update_tms)){
print(paste("Updating at time t =", update_tms[i]))
prior_pk <- prior$pars_pkpd[prior$pk_ix]
prior_pd <- prior$pars_pkpd[-prior$pk_ix]
# subset targets and observation times to period being updated
targets_sub <- targets[targets$time <= update_tms[i] & targets$time >= update_tms[i-1],]
obs_tms_sub <- obs_tms[obs_tms <= update_tms[i] & obs_tms > update_tms[i-1]]
# calculate tci infusions at prior parameter estimates for update period
inf <- tci_pd(pdresp  = targets_sub$target,
tms     = targets_sub$time,
pdinv   = pdinv,
pdmod   = pdmod,
pkmod   = pkmod,
pars_pk = prior_pk,
pars_pd = prior_pd,
init = init_p,
tci_alg = tci_alg)
# generate data under true model
dat <- gen_data(inf = inf,
tms = obs_tms_sub,
pkmod = pkmod,
pdmod = pdmod,
pars_pk0 = true_pk, # true pk parameters
pars_pd0 = true_pd, # true pd parameters
sigma_add = true_pars$err, # random error
delay = true_pars$delay, # bis delay in minutes
max_pdval = 100,
init = init0)
# merge sampled dataset with prior observations
dat0 <- combine_sim(dat0,dat)
# indicate if full dataset should be used for updates
if(update_full[i]){
dat_eval <- dat0
} else dat_eval <- dat
# update parameters based on generated data
# use prior parameter values as starting point - separate fixed parameters
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
# update parameter estimates with data
post_est <- nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior$sig,
fixed_lpr = lpr_fixed,
hessian = T)
if(plot_progress[i]){
print(plot(dat0, lpars_update = post_est$estimate))
}
# update prior values
if(any(!is.null(prior$fixed_ix))){
prior$pars_pkpd[-prior$fixed_ix] <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
} else{
prior$pars_pkpd <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
}
prior$sig <- solve(post_est$hessian)
# update true and predicted initial values
init0 <- dat0$sim[nrow(dat0$sim),grep("c[0-9]",colnames(dat0$sim))]
init_p <- as.numeric(predict(pkmod,
inf = dat$inf,
tms = update_tms[i],
pars = prior$pars_pkpd[prior$pk_ix],
init = init_p)[-1])
}
return(list(dat = dat0,
lpr = lpr_all,
posterior = prior,
prior = prior0,
true_pars = true_pars))
}
#' Function to provide Bayesian closed-loop control to
#' @param targets Dataframe with columns ("time","target")
#' @param updates Dataframe of times at which closed-loop updates should be conducted and
#' optional variable with logical values named 'full_data' indicating if full updates should
#' be used. Defaults to partial.
#' @param prior List with elements "mu" and "sig" specifying the prior mean and covariance
#' matrices for the logged parameter values.
#' @param obs_tms Times at which observations are collected. If null, observations will be
#' made at fixed intervals specified by 'dt'.
#' @param dt Interval between measurements.
bayes_control <- function(targets, updates, prior, true_pars,
pkmod = pkmod3cptm, pdmod = emax_eleveld, pdinv = inv_emax_eleveld,
init0 = NULL, init_p = NULL, obs_tms = NULL, dt = 1/60, sim_starttm = 0,
tci_alg = "effect"){
# set observation/measurement times
if(is.null(obs_tms)) obs_tms <- seq(dt, max(targets$time), dt)
# set true and predicted initial concentrations if not specified
ncpt <- length(eval(formals(pkmod)$init))
if(is.null(init0)) init0 <- rep(0,ncpt)
if(is.null(init_p)) init_p <- rep(0,ncpt)
if(is.vector(updates)) updates <- data.frame(time = updates)
if("time" %nin% names(updates)) stop("dataframe updates must have column named 'time'")
if("full_data" %nin% names(updates)) updates$full_data <- FALSE
if("plot_progress" %nin% names(updates)) updates$plot_progress <- FALSE
# add simulation start time to list of update times
update_tms <- c(sim_starttm, updates$time)
update_full <- c(NA, updates$full_data)
plot_progress <- c(NA, updates$plot_progress)
true_pk <- true_pars$pars_pkpd[true_pars$pk_ix]
true_pd <- true_pars$pars_pkpd[-true_pars$pk_ix]
prior0 <- prior
dat0 <- NULL
lpr_all <- NULL
for(i in 2:length(update_tms)){
print(paste("Updating at time t =", update_tms[i]))
prior_pk <- prior$pars_pkpd[prior$pk_ix]
prior_pd <- prior$pars_pkpd[-prior$pk_ix]
# subset targets and observation times to period being updated
targets_sub <- targets[targets$time <= update_tms[i] & targets$time >= update_tms[i-1],]
obs_tms_sub <- obs_tms[obs_tms <= update_tms[i] & obs_tms > update_tms[i-1]]
# calculate tci infusions at prior parameter estimates for update period
inf <- tci_pd(pdresp  = targets_sub$target,
tms     = targets_sub$time,
pdinv   = pdinv,
pdmod   = pdmod,
pkmod   = pkmod,
pars_pk = prior_pk,
pars_pd = prior_pd,
init = init_p,
tci_alg = tci_alg)
# generate data under true model
dat <- gen_data(inf = inf,
tms = obs_tms_sub,
pkmod = pkmod,
pdmod = pdmod,
pars_pk0 = true_pk, # true pk parameters
pars_pd0 = true_pd, # true pd parameters
sigma_add = true_pars$err, # random error
delay = true_pars$delay, # bis delay in minutes
max_pdval = 100,
init = init0)
# merge sampled dataset with prior observations
dat0 <- combine_sim(dat0,dat)
# indicate if full dataset should be used for updates
if(update_full[i]){
dat_eval <- dat0
} else dat_eval <- dat
# update parameters based on generated data
# use prior parameter values as starting point - separate fixed parameters
if(any(!is.null(prior$fixed_ix))){
lpr <- log(c(prior$pars_pkpd[-prior$fixed_ix], err = prior$err))
lpr_fixed <- log(prior$pars_pkpd[prior$fixed_ix])
} else{
lpr <- log(c(prior$pars_pkpd, err = prior$err))
lpk_fixed <- NULL
}
lpr_all <- rbind(lpr_all, lpr)
# update parameter estimates with data
post_est <- nlm(f = log_posterior_neg,
p = lpr,
dat = dat_eval,
mu = lpr,
sig = prior$sig,
fixed_lpr = lpr_fixed,
hessian = T)
if(plot_progress[i]){
print(plot(dat0, lpars_update = post_est$estimate))
}
# update prior values
if(any(!is.null(prior$fixed_ix))){
prior$pars_pkpd[-prior$fixed_ix] <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
} else{
prior$pars_pkpd <- exp(head(post_est$estimate,-1))
prior$err <- exp(tail(post_est$estimate,1))
}
prior$sig <- solve(post_est$hessian)
# update true and predicted initial values
init0 <- dat0$sim[nrow(dat0$sim),grep("c[0-9]",colnames(dat0$sim))]
init_p <- as.numeric(predict(pkmod,
inf = dat$inf,
tms = update_tms[i],
pars = prior$pars_pkpd[prior$pk_ix],
init = init_p)[-1])
}
return(list(dat = dat0,
lpr = lpr_all,
posterior = prior,
prior = prior0,
true_pars = true_pars))
}
rep(c(F,T),5)
# specify times of updates and whether the full dataset should be used or only
# the most recently collected samples - full updates for first three minutes, followed
# by partial updates for the remaining seven.
updates <- data.frame(time = 1:10,
full_data = c(rep(TRUE,3), rep(FALSE,7)),
plot_progress = rep(c(F,T),5))
set.seed(2)
bayes_sim <- bayes_control(targets = targets,
updates = updates,
prior = prior,
true_pars = true_pars,
plot_progres = TRUE)
bayes_sim <- bayes_control(targets = targets,
updates = updates,
prior = prior,
true_pars = true_pars)
