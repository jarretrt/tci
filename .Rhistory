init = c(1,0,0,0), title = "Infusion required to reach a plasma concentration of 2 in a 3cmpt model")
cut
library(tci)
library(tci)
create_intvl
library(tci)
(dose <- create_intvl(as.matrix(cbind(time = c(0.5,4,4.5,10), infrt = c(100,0,100,0)))))
pars_1cpt <- c(ke = 0.1, v = 10)
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
# predict for 1cpt model
head(predict(pkmod = pkmod1cpt, inf = dose, pars = pars_1cpt, init = 2, return_init = T))
# predict for 1cpt model
head(predict(pkmod1cpt, inf = dose, pars = pars_1cpt, init = 2, return_init = T))
# predict for 3cpt model
head(predict(pkmod3cptm, inf = dose, pars = pars_3cpt, return_init = T))
# predict for 3cpt model at specific values
predict(pkmod3cptm, inf = dose, pars = pars_3cpt, tms = c(1,2,3))
plot(pkmod1cpt, inf = dose, pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
dose
pkmod1cpt
plot(x = pkmod1cpt, inf = dose, pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
library(tci)
(dose <- create_intvl(as.matrix(cbind(time = c(0.5,4,4.5,10), infrt = c(100,0,100,0)))))
pars_1cpt <- c(ke = 0.1, v = 10)
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
# predict for 1cpt model
head(predict(pkmod1cpt, inf = dose, pars = pars_1cpt, init = 2, return_init = T))
# predict for 3cpt model
head(predict(pkmod3cptm, inf = dose, pars = pars_3cpt, return_init = T))
# predict for 3cpt model at specific values
predict(pkmod3cptm, inf = dose, pars = pars_3cpt, tms = c(1,2,3))
plot(pkmod1cpt, inf = dose, pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
debug(plot.pkmod)
getAnywhere("plot.pkmod")
library(tci)
plot(pkmod1cpt, inf = dose, pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
plot(pkmod3cptm, inf = dose, pars = pars_3cpt, title = "Concentrations for a 3 compartment model with an effect site")
# find infusion to increase plasma concentration to 2 within 2 minutes.
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod1cpt, pars = pars_1cpt)
# verify that infusion will reach target at 2 minutes
plot(pkmod1cpt, pars = pars_1cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est,0))),
title = "Infusion required to reach a plasma concentration of 2")
# test for 3 compartment model with initial concentration in central compartment
inf_est <- tci_plasma(Cpt = 2, dt = 2, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0))
plot(pkmod3cptm, pars = pars_3cpt, inf =  create_intvl(data.frame(time = c(2, 20), infrt = c(inf_est,0))),
init = c(1,0,0,0), title = "Infusion required to reach a plasma concentration of 2 in a 3cmpt model")
# calculate the 10 second infusion rate required to reach a concentration of 1 ug/ml in the effect-site compartment with existing drug in the first compartment.
kR_Cet <- tci_effect(Cet = 1, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0), dt = 1/6)
inf <- create_intvl(data.frame(time = c(1/6, 20), infrt = c(kR_Cet,0)))
plot(pkmod3cptm, inf, pars = pars_3cpt, init = c(1,0,0,0),
title = "10-sec infusion to reach a Cet of 1 in a 3cmpt model with initial cons")
inf
# calculate the 10 second infusion rate required to reach a concentration of 1 ug/ml in the effect-site compartment with existing drug in the first compartment.
kR_Cet <- tci_effect(Cet = 1, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(1,0,0,0), dt = 1/6)
kR_Cet
inf <- create_intvl(data.frame(time = c(1/6, 20), infrt = c(kR_Cet,0)))
plot(pkmod3cptm, inf, pars = pars_3cpt, init = c(1,0,0,0),
title = "10-sec infusion to reach a Cet of 1 in a 3cmpt model with initial cons")
pkmod3cptm
plot(pkmod3cptm, inf = inf, pars = pars_3cpt, init = c(1,0,0,0),
title = "10-sec infusion to reach a Cet of 1 in a 3cmpt model with initial cons")
# The algorithm may also be used to specify target different compartments, if desired.
# Find 1 minute infusion required to reach a concentration of 0.5 in compartment 2 with no prior infusions.
infdt = 1
kR_Cet_cmpt2 <- tci_effect(Cet = 0.5, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(0,0,0,0), dt = infdt, cmpt = 2)
inf_cmpt2 <- create_intvl(data.frame(time = c(infdt, 20), infrt = c(kR_Cet_cmpt2,0)))
plot(pkmod3cptm, inf = inf_cmpt2, pars = pars_3cpt, init = c(0,0,0,0),
title = "1-min infusion to reach a c2 con of 0.5 in a 3cmpt model")
tms <- c(0,5,10,15)
Cet <- c(2,1.5,1,1)
# one compartment model
tci_1cpt <- tci(Cet, tms, pkmod = pkmod1cpt, pars = pars_1cpt, tci_alg = "plasma")
plot(tci_1cpt, title = "Plasma-targeting for one-compartment model")
# three compartment model
tci_3cpt <- tci(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt, tci_alg = "plasma")
plot(tci_3cpt, title = "Plasma-targeting for three-compartment model")
# effect-site targeting
tci_3cpt_effect <- tci(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt)
plot(tci_3cpt_effect, title = "Effect-site targeting for three-compartment model")
# effect-site targeting with initial concentrations
tci_3cpt_effect_init <- tci(Cet, tms, pkmod = pkmod3cptm, pars = pars_3cpt, init = c(2,0,0,2))
plot(tci_3cpt_effect_init, title = "Effect-site targeting for three-compartment model and initial concentrations")
# Emax model
pars_emax <- c(c50 = 1.5, gamma = 4, e0 = 100, emx = 100)
ce_seq <- seq(0,4,0.1)
# inverse Emax model
all.equal(inv_emax(emax(ce_seq, pars_emax), pars_emax), ce_seq)
plot(pdmod = emax,
pkmod = pkmod3cptm,
pars_pd = pars_emax,
pars_pk = pars_3cpt,
inf = create_intvl(data.frame(time = c(2,4,6,10),
infrt = c(400,0,400,0))),
title = "Predicted PK-PD responses")
library(tci)
plot(pdmod = emax,
pkmod = pkmod3cptm,
pars_pd = pars_emax,
pars_pk = pars_3cpt,
inf = create_intvl(data.frame(time = c(2,4,6,10),
infrt = c(400,0,400,0))),
title = "Predicted PK-PD responses")
plot(pdmod = emax,
pkmod = pkmod3cptm,
pars_pd = pars_emax,
pars_pk = pars_3cpt,
inf = create_intvl(data.frame(time = c(2,4,6,10),
infrt = c(400,0,400,0))),
title = "Predicted PK-PD responses")
plot(x = emax,
pkmod = pkmod3cptm,
pars_pd = pars_emax,
pars_pk = pars_3cpt,
inf = create_intvl(data.frame(time = c(2,4,6,10),
infrt = c(400,0,400,0))),
title = "Predicted PK-PD responses")
tms <- seq(0,15,5)
bist <- c(40,50,70,70)
tci_bis_res <- tci_pd(pdresp = bist,
tms = tms,
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
# plot TCI object with pd response
plot(tci_bis_res, title = "Extension of TCI algorithm to PD targets")
# Simulate PK-PD data under model misspecification.
# true parameters: pars_3cpt0, pars_emax0
# prior parameters: pars_3cpt, pars_emax
pars_3cpt0 <- c(k10=1.7,k12=0.13,k21=0.1,k13=0.8,k31=0.8,v1=15,v2=16,v3=90,ke0=1.2)
pars_emax0 <- c(c50 = 1.2, gamma = 3.5, e0 = 100, emx = 100)
# Predicted concentrations / responses under model with pars "pars_3cpt", "pars_emax"
tci_bis_res <- tci_pd(pdresp = c(40,50,70,70),
tms = c(0,5,10,15),
pdinv = inv_emax,
pdmod = emax,
pkmod = pkmod3cptm,
pars_pk = pars_3cpt,
pars_pd = pars_emax)
# Generate data using infusion schedule above under a different PK-PD model
pkpddsim <- gen_data(inf = tci_bis_res,
pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0,
pdmod = emax, pars_pd0 = pars_emax0,
sigma_add = 7)
library(tci)
# Generate data using infusion schedule above under a different PK-PD model
pkpddsim <- gen_data(inf = tci_bis_res,
pkmod = pkmod3cptm, pars_pk0 = pars_3cpt0,
pdmod = emax, pars_pd0 = pars_emax0,
sigma_add = 7)
library(tci)
gen_data
library(tci)
?cut2
restrict_sigmoid
tci_comb
MALE = c(TRUE,FALSE,TRUE))
dat <- data.frame(AGE  = c(20,40,65),
TBM  = c(50,70,90),
HGT  = c(150,170,200),
MALE = c(TRUE,FALSE,TRUE))
schnider_poppk(dat, rand = FALSE, rate = FALSE)
schnider_poppk(dat, rand = TRUE, rate = TRUE)
?head
library(tci)
data("eleveld_pk")
data()
library(tci)
data("eleveld_pk")
data("eleveld_pd")
View(eleveld_pk)
save(eleveld_pk, file = "./data/eleveld_pk.rda")
save(eleveld_pd, file = "./data/eleveld_pd.rda")
pkmod3cptm
library(tci)
pkmod3cptm
pkmod
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
debug(assign_pk_pars)
assign_pk_pars(pkmod3cptm, pars_3cpt)
assign_pk_pars <- function(pkmod, pars){
if(class(pkmod) != "pkmod") stop("Class of pkmod must be 'pkmod'.")
formals(pkmod)
}
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
debug(assign_pk_pars)
assign_pk_pars(pkmod3cptm, pars_3cpt)
class(pkmod) != "pkmod"
formals(pkmod)
!("pars" in formals(pkmod))
!("pars" %in% formals(pkmod))
names(formals(pkmod))
"pars" %in% names(formals(pkmod))
!("pars" %in% names(formals(pkmod)))
formals(pkmod)$pars
formals(pkmod)$pars <- pars
pkmod
formals(pkmod3cptm)$pars <- pars_3cpt
head(predict(pkmod3cptm, inf = dose, return_init = T))
pkmod3cptm
library(tci)
pkmod3cptm
pkmod1cpt
pkmod3cptm
assign_pk_pars <- function(pkmod, pars){
if(class(pkmod) != "pkmod") stop("Class of pkmod must be 'pkmod'")
if(!("pars" %in% names(formals(pkmod)))) stop("Object 'pkmod' must have argument 'pars'")
formals(pkmod)$pars <- pars
class(pkmod) <- "pkmod"
return(pkmod)
}
rm(pkmod3cptm)
pkmod3cptm
assign_pk_pars(pdmod3cmptm, assign_pk_pars)
assign_pk_pars(pkmod3cptm, assign_pk_pars)
pkmod3cmptm2 <- assign_pk_pars(pkmod3cptm, assign_pk_pars)
predict(pkmod3cmptm2, inf = dose, return_init = T)
(dose <- create_intvl(as.matrix(cbind(time = c(0.5,4,4.5,10), infrt = c(100,0,100,0)))))
predict(pkmod3cmptm2, inf = dose, return_init = T)
pkmod1cpt
predict_pkmod <- function(object, ..., inf, tms = NULL, dt = 1/6, return_init = FALSE,
remove_bounds = TRUE, tm_digits = 7){
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
if(!is.null(tms) & any(tms > max(inf[,"end"])))
stop("Prediction time points are outside range of dosing interval")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.null(eval(formals(object)$pars)))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
# Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dt.
if(!is.null(tms)){
# round times - this is needed to prevent errors associated with rounding numeric values
tms <- round(tms, tm_digits)
# if times are provided, predict at those times plus boundaries for initial values
b <- sort(unique(
round(as.numeric(unlist(inf[,c("begin","end")])),tm_digits)
))
tms_all <- sort(unique(
round(c(b,tms),tm_digits)
))
tms_eval <- split(tms_all, findInterval(tms_all, b,
rightmost.closed = TRUE,
left.open = TRUE))
} else{
# if times are not provided, predict across a grid of points
tms_eval <- mapply(seq, inf[,"begin"]+dt, inf[,"end"], by = dt,
SIMPLIFY = FALSE)
tms_all <- unlist(tms_eval)
}
init <- vector("list", nrow(inf)+1)
# Pass on initial concentrations to first element of init. Use values if specified, else defaults.
if("init" %in% names(dot.args)){
init[[1]] <- unlist(dot.args$init)
dot.args$init <- NULL
} else {
init[[1]] <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$init)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$init)
}
# get indexes of times and initialize matrix for predictions
tm_ix <- lapply(tms_eval, function(x) match(x,tms_all))
ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
pkmod3cptm
pkmod3cptm2
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
pkmod3cptm2 <- assign_pk_pars(pkmod3cptm, pars_3cpt)
pkmod3cptm2
head(pkmod3cptm2)
pkmod3cptm2(tm = 1, kR = 1)
predict_pkmod(pkmod3cptm2, inf = dose, pars = pars_3cpt, return_init = T)
debug(predict_pkmod)
predict_pkmod(pkmod3cptm2, inf = dose, pars = pars_3cpt, return_init = T)
dot.args
!("pars" %in% names(dot.args))
is.null(eval(formals(object)$pars))
"pars" %in% names(dot.args)
unlist(dot.args$pars)
eval(formals(object)$pars)
predict_pkmod <- function(object, ..., inf, tms = NULL, dt = 1/6, return_init = FALSE,
remove_bounds = TRUE, tm_digits = 7){
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
if(!is.null(tms) & any(tms > max(inf[,"end"])))
stop("Prediction time points are outside range of dosing interval")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.null(eval(formals(object)$pars)))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
# Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dt.
if(!is.null(tms)){
# round times - this is needed to prevent errors associated with rounding numeric values
tms <- round(tms, tm_digits)
# if times are provided, predict at those times plus boundaries for initial values
b <- sort(unique(
round(as.numeric(unlist(inf[,c("begin","end")])),tm_digits)
))
tms_all <- sort(unique(
round(c(b,tms),tm_digits)
))
tms_eval <- split(tms_all, findInterval(tms_all, b,
rightmost.closed = TRUE,
left.open = TRUE))
} else{
# if times are not provided, predict across a grid of points
tms_eval <- mapply(seq, inf[,"begin"]+dt, inf[,"end"], by = dt,
SIMPLIFY = FALSE)
tms_all <- unlist(tms_eval)
}
init <- vector("list", nrow(inf)+1)
# Pass on initial concentrations to first element of init. Use values if specified, else defaults.
if("init" %in% names(dot.args)){
init[[1]] <- unlist(dot.args$init)
dot.args$init <- NULL
} else {
init[[1]] <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
# get indexes of times and initialize matrix for predictions
tm_ix <- lapply(tms_eval, function(x) match(x,tms_all))
ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
debug(predict_pkmod)
predict_pkmod(pkmod3cptm2, inf = dose, return_init = T)
eval(formals(object)$pars)
do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
dot.args
predict_pkmod <- function(object, ..., inf, tms = NULL, dt = 1/6, return_init = FALSE,
remove_bounds = TRUE, tm_digits = 7){
if(!all(c("infrt","begin","end") %in% colnames(inf)))
stop("inf must include 'infrt','begin','end' as column names")
if(!is.null(tms) & any(tms > max(inf[,"end"])))
stop("Prediction time points are outside range of dosing interval")
dot.args <- list(...)
if(!("init" %in% names(formals(object))))
stop("object must contain argument 'init'")
if(!("pars" %in% names(dot.args)) &
is.null(eval(formals(object)$pars)))
stop("PK parameters must be passed as 'pars' within predict or set
as defaults in PK model object")
# Times to evaluate concentrations at. Defaults to a sequence of values at intervals of dt.
if(!is.null(tms)){
# round times - this is needed to prevent errors associated with rounding numeric values
tms <- round(tms, tm_digits)
# if times are provided, predict at those times plus boundaries for initial values
b <- sort(unique(
round(as.numeric(unlist(inf[,c("begin","end")])),tm_digits)
))
tms_all <- sort(unique(
round(c(b,tms),tm_digits)
))
tms_eval <- split(tms_all, findInterval(tms_all, b,
rightmost.closed = TRUE,
left.open = TRUE))
} else{
# if times are not provided, predict across a grid of points
tms_eval <- mapply(seq, inf[,"begin"]+dt, inf[,"end"], by = dt,
SIMPLIFY = FALSE)
tms_all <- unlist(tms_eval)
}
init <- vector("list", nrow(inf)+1)
# Pass on initial concentrations to first element of init. Use values if specified, else defaults.
if("init" %in% names(dot.args)){
init[[1]] <- unlist(dot.args$init)
dot.args$init <- NULL
} else {
init[[1]] <- eval(formals(object)$init)
}
if("pars" %in% names(dot.args)){
pars <- unlist(dot.args$pars)
dot.args$pars <- NULL
} else {
pars <- eval(formals(object)$pars)
}
# get indexes of times and initialize matrix for predictions
tm_ix <- lapply(tms_eval, function(x) match(x,tms_all))
ncmpt <- length(eval(formals(object)$init))
pred <- matrix(NA, nrow = ncmpt, ncol = length(tms_all))
# Predict concentrations and store initial values.
for(i in 1:nrow(inf)){
pred[,tm_ix[[i]]] <- do.call("object", c(list(tm = tms_eval[[i]],
kR = inf[i,"infrt"],
pars = pars,
init = init[[i]],
inittm = inf[i,"begin"]),
dot.args))
init[[i+1]] <- pred[,length(unlist(tm_ix[1:i]))]
}
# Replace any negative values
pred[pred<0] <- 0
# Return predicted concentrations
if(dim(pred)[1] == 1) {
predtms <- cbind(unique(unlist(tms_eval)), c(pred))
} else{
predtms <- cbind(unique(unlist(tms_eval)), t.default(pred))
}
# Add on t=0 concentrations
if(return_init) predtms <- rbind(c(inf[1,"begin"], init[[1]]), predtms)
# # remove transition concentrations
if(!is.null(tms) & remove_bounds){
predtms <- matrix(predtms[which(predtms[,1] %in% tms),],
nrow = length(tms), byrow = FALSE)
}
colnames(predtms) <- c("time",paste0("c",1:length(init[[1]])))
return(predtms)
}
predict_pkmod(pkmod3cptm2, inf = dose, return_init = T)
predict_pkmod(pkmod3cptm2, inf = dose, pars = pars_3cpt, return_init = T)
predict_pkmod(pkmod3cptm2, inf = dose, return_init = T)
predict_pkmod(pkmod3cptm2, inf = dose, pars = pars_3cpt, return_init = T)
library(tci)
library(tci)
(dose <- create_intvl(as.matrix(cbind(time = c(0.5,4,4.5,10), infrt = c(100,0,100,0)))))
pars_1cpt <- c(ke = 0.1, v = 10)
pars_3cpt <- c(k10=1.5,k12=0.15,k21=0.09,k13=0.8,k31=0.8,v1=10,v2=15,v3=100,ke0=1)
# predict for 1cpt model
head(predict(pkmod1cpt, inf = dose, pars = pars_1cpt, init = 2, return_init = T))
# predict for 3cpt model
head(predict(pkmod3cptm, inf = dose, pars = pars_3cpt, return_init = T))
# predict for 3cpt model at specific values
predict(pkmod3cptm, inf = dose, pars = pars_3cpt, tms = c(1,2,3))
plot(pkmod1cpt, inf = dose, pars = pars_1cpt, title = "Plasma concentrations for a 1 compartment model")
plot(pkmod3cptm, inf = dose, pars = pars_3cpt, title = "Concentrations for a 3 compartment model with an effect site")
pkmod3cmptm2 <- assign_pk_pars(pkmod3cptm, assign_pk_pars)
library(tci)
pkmod3cmptm2 <- assign_pk_pars(pkmod3cptm, assign_pk_pars)
pkmod3cmptm2 <- assign_pars(pkmod3cptm, assign_pk_pars)
??assign_pars
library(tci)
assign_pars
elvdlpars
assign_pars
?assign_pars
